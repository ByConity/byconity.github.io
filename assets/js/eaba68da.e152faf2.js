"use strict";(self.webpackChunkbyconity=self.webpackChunkbyconity||[]).push([[7878],{9613:(e,t,a)=>{a.d(t,{Zo:()=>p,kt:()=>h});var n=a(9496);function r(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function i(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);t&&(n=n.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,n)}return a}function l(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?i(Object(a),!0).forEach((function(t){r(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):i(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function o(e,t){if(null==e)return{};var a,n,r=function(e,t){if(null==e)return{};var a,n,r={},i=Object.keys(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||(r[a]=e[a]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(n=0;n<i.length;n++)a=i[n],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(r[a]=e[a])}return r}var d=n.createContext({}),s=function(e){var t=n.useContext(d),a=t;return e&&(a="function"==typeof e?e(t):l(l({},t),e)),a},p=function(e){var t=s(e.components);return n.createElement(d.Provider,{value:t},e.children)},c="mdxType",u={inlineCode:"code",wrapper:function(e){var t=e.children;return n.createElement(n.Fragment,{},t)}},m=n.forwardRef((function(e,t){var a=e.components,r=e.mdxType,i=e.originalType,d=e.parentName,p=o(e,["components","mdxType","originalType","parentName"]),c=s(a),m=r,h=c["".concat(d,".").concat(m)]||c[m]||u[m]||i;return a?n.createElement(h,l(l({ref:t},p),{},{components:a})):n.createElement(h,l({ref:t},p))}));function h(e,t){var a=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=a.length,l=new Array(i);l[0]=m;var o={};for(var d in t)hasOwnProperty.call(t,d)&&(o[d]=t[d]);o.originalType=e,o[c]="string"==typeof e?e:r,l[1]=o;for(var s=2;s<i;s++)l[s]=a[s];return n.createElement.apply(null,l)}return n.createElement.apply(null,a)}m.displayName="MDXCreateElement"},1132:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>d,contentTitle:()=>l,default:()=>u,frontMatter:()=>i,metadata:()=>o,toc:()=>s});var n=a(4778),r=(a(9496),a(9613));const i={title:"Cache Preload",sidebar_position:2,tags:["Docs"]},l="Cache Preload",o={unversionedId:"query-optimization/query-optimization-with-cache-preload",id:"query-optimization/query-optimization-with-cache-preload",title:"Cache Preload",description:"Data Caching (Disk Cache)",source:"@site/docs/query-optimization/query-optimization-with-cache-preload.mdx",sourceDirName:"query-optimization",slug:"/query-optimization/query-optimization-with-cache-preload",permalink:"/docs/query-optimization/query-optimization-with-cache-preload",draft:!1,editUrl:"https://github.com/ByConity/byconity.github.io/tree/main/docs/query-optimization/query-optimization-with-cache-preload.mdx",tags:[{label:"Docs",permalink:"/docs/tags/docs"}],version:"current",sidebarPosition:2,frontMatter:{title:"Cache Preload",sidebar_position:2,tags:["Docs"]},sidebar:"tutorialSidebar",previous:{title:"Query Optimizer",permalink:"/docs/query-optimization/query-optimizer"},next:{title:"Complex Query Tuning",permalink:"/docs/query-optimization/complex-query-optimization"}},d={},s=[{value:"Data Caching (Disk Cache)",id:"data-caching-disk-cache",level:2},{value:"Preloading (Cache Preload)",id:"preloading-cache-preload",level:2},{value:"How to Enable and Configure",id:"how-to-enable-and-configure",level:3},{value:"Manual Preloading",id:"manual-preloading",level:3}],p={toc:s},c="wrapper";function u(e){let{components:t,...i}=e;return(0,r.kt)(c,(0,n.Z)({},p,i,{components:t,mdxType:"MDXLayout"}),(0,r.kt)("h1",{id:"cache-preload"},"Cache Preload"),(0,r.kt)("h2",{id:"data-caching-disk-cache"},"Data Caching (Disk Cache)"),(0,r.kt)("p",null,"In the storage-compute separation architecture of ByConity, the use of cloud storage elongates I/O times. To address this issue, ByConity optimizes read-write performance by implementing a Disk Cache on each Worker. When data from remote storage is accessed, a local copy is cached on the Worker for faster subsequent access. If the Cache becomes full, ByConity employs an enhanced Bucket LRU algorithm to evict data. Additionally, ByConity caches metadata in the Server's memory, using Tables and Partitions as granularity.\n",(0,r.kt)("img",{src:a(4352).Z,width:"1280",height:"527"})),(0,r.kt)("h2",{id:"preloading-cache-preload"},"Preloading (Cache Preload)"),(0,r.kt)("p",null,"In version 0.2.0, ByConity introduced optimizations for cold reads by supporting the Cache Preload feature. In the storage-compute separation architecture, the Disk Cache concept is utilized, where accessed data is cached and eviction strategies are employed to remove data that hasn't been accessed recently or infrequently. However, cold reads can still occur, degrading read-write performance. Therefore, it's desirable to accelerate the data loading process, essentially \"preheating\" the cache by loading data before user queries."),(0,r.kt)("p",null,"Preloading involves fetching data from remote storage and storing it in the local disk cache beforehand, thus speeding up impending queries. Once preloading is complete, queries can directly read data from the local disk rather than remote storage. Currently, Cache Preload supports two types: Automatic Preload and Manual Preload. Additionally, preloading can be configured to include only metadata (Meta), only data (Data), or both Meta and Data simultaneously."),(0,r.kt)("h3",{id:"how-to-enable-and-configure"},"How to Enable and Configure"),(0,r.kt)("ol",null,(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Set the table-level ",(0,r.kt)("inlineCode",{parentName:"p"},"parts_preload_level")," to a value greater than 0 (defaults to 0 if not set). This can be updated using the following DDL command:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE [db.]table_name MODIFY SETTING parts_preload_level = {level};\n")),(0,r.kt)("p",{parentName:"li"},"Where ",(0,r.kt)("inlineCode",{parentName:"p"},"{level}")," has the following meanings:"),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"0: Disable preloading for the table."),(0,r.kt)("li",{parentName:"ul"},"1: Enable preloading for the table, but only preload metadata including checksums, primary indexes, and markers."),(0,r.kt)("li",{parentName:"ul"},"2: Enable preloading for the table, but only preload data, excluding metadata."),(0,r.kt)("li",{parentName:"ul"},"3: Enable preloading for the table, preload both metadata and some data."))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Ensure the table-level ",(0,r.kt)("inlineCode",{parentName:"p"},"enable_local_disk_cache")," is set to 1 (defaults to 1 if not set). This can be updated using the following DDL command:"),(0,r.kt)("pre",{parentName:"li"},(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER TABLE [db.]table_name MODIFY SETTING enable_local_disk_cache = 1;\n"))),(0,r.kt)("li",{parentName:"ol"},(0,r.kt)("p",{parentName:"li"},"Set the system-level ",(0,r.kt)("inlineCode",{parentName:"p"},"parts_preload_level")," in the ",(0,r.kt)("inlineCode",{parentName:"p"},"user.xml")," configuration file to a value greater than 0 (defaults to 1)."),(0,r.kt)("ul",{parentName:"li"},(0,r.kt)("li",{parentName:"ul"},"0: Disable preloading globally. This means preloading operations will be turned off for all tables, even if the table-level ",(0,r.kt)("inlineCode",{parentName:"li"},"parts_preload_level")," is set to a value greater than 0."),(0,r.kt)("li",{parentName:"ul"},"1: Allow table-level preloading operations, and the actual preloading level will depend on the table settings.")))),(0,r.kt)("h3",{id:"manual-preloading"},"Manual Preloading"),(0,r.kt)("p",null,"For older data in tables where preloading was not enabled initially, manual preloading can be triggered using the following DDL:"),(0,r.kt)("pre",null,(0,r.kt)("code",{parentName:"pre",className:"language-sql"},"ALTER DISK CACHE PRELOAD TABLE [db.]table_name [PARTITION p] [SYNC|ASYNC] [SETTINGS parts_preload_level = {level}, virtual_warehouse = {vw_name}];\n")),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Partition ",(0,r.kt)("inlineCode",{parentName:"li"},"p"),": Specifies the target partition for loading. If omitted, all data within the table will be preloaded by default."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"SYNC"),"|",(0,r.kt)("inlineCode",{parentName:"li"},"ASYNC"),": Determines whether preloading should be synchronous or asynchronous. ",(0,r.kt)("inlineCode",{parentName:"li"},"ASYNC")," returns success immediately, while ",(0,r.kt)("inlineCode",{parentName:"li"},"SYNC")," blocks until preloading is complete."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"parts_preload_level"),": Overrides the table-level preloading level for manual preloading if specified."),(0,r.kt)("li",{parentName:"ul"},(0,r.kt)("inlineCode",{parentName:"li"},"virtual_warehouse"),": Specifies the target virtual warehouse node for preloading.")),(0,r.kt)("p",null,"Notes:"),(0,r.kt)("ul",null,(0,r.kt)("li",{parentName:"ul"},"Newly inserted data is automatically preloaded to the local disk. The target vw node is determined by the ",(0,r.kt)("inlineCode",{parentName:"li"},"virtual_warehouse")," binding in the table settings, and the preloading level depends on the ",(0,r.kt)("inlineCode",{parentName:"li"},"parts_preload_level")," table setting."),(0,r.kt)("li",{parentName:"ul"},"Data resulting from merges is also automatically preloaded to the local disk. The target vw node and preloading level are determined similarly based on the table settings.")))}u.isMDXComponent=!0},4352:(e,t,a)=>{a.d(t,{Z:()=>n});const n=a.p+"assets/images/disk-cache-b943e84f01ac248b6b5ffb7466c23284.png"}}]);