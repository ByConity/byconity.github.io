"use strict";(self.webpackChunkbyconity=self.webpackChunkbyconity||[]).push([[2774],{9613:(e,t,a)=>{a.d(t,{Zo:()=>m,kt:()=>f});var r=a(9496);function i(e,t,a){return t in e?Object.defineProperty(e,t,{value:a,enumerable:!0,configurable:!0,writable:!0}):e[t]=a,e}function n(e,t){var a=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),a.push.apply(a,r)}return a}function o(e){for(var t=1;t<arguments.length;t++){var a=null!=arguments[t]?arguments[t]:{};t%2?n(Object(a),!0).forEach((function(t){i(e,t,a[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(a)):n(Object(a)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(a,t))}))}return e}function l(e,t){if(null==e)return{};var a,r,i=function(e,t){if(null==e)return{};var a,r,i={},n=Object.keys(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||(i[a]=e[a]);return i}(e,t);if(Object.getOwnPropertySymbols){var n=Object.getOwnPropertySymbols(e);for(r=0;r<n.length;r++)a=n[r],t.indexOf(a)>=0||Object.prototype.propertyIsEnumerable.call(e,a)&&(i[a]=e[a])}return i}var s=r.createContext({}),u=function(e){var t=r.useContext(s),a=t;return e&&(a="function"==typeof e?e(t):o(o({},t),e)),a},m=function(e){var t=u(e.components);return r.createElement(s.Provider,{value:t},e.children)},c="mdxType",p={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},d=r.forwardRef((function(e,t){var a=e.components,i=e.mdxType,n=e.originalType,s=e.parentName,m=l(e,["components","mdxType","originalType","parentName"]),c=u(a),d=i,f=c["".concat(s,".").concat(d)]||c[d]||p[d]||n;return a?r.createElement(f,o(o({ref:t},m),{},{components:a})):r.createElement(f,o({ref:t},m))}));function f(e,t){var a=arguments,i=t&&t.mdxType;if("string"==typeof e||i){var n=a.length,o=new Array(n);o[0]=d;var l={};for(var s in t)hasOwnProperty.call(t,s)&&(l[s]=t[s]);l.originalType=e,l[c]="string"==typeof e?e:i,o[1]=l;for(var u=2;u<n;u++)o[u]=a[u];return r.createElement.apply(null,o)}return r.createElement.apply(null,a)}d.displayName="MDXCreateElement"},94:(e,t,a)=>{a.r(t),a.d(t,{assets:()=>s,contentTitle:()=>o,default:()=>p,frontMatter:()=>n,metadata:()=>l,toc:()=>u});var r=a(4778),i=(a(9496),a(9613));const n={title:"Import Optimisation",tags:["Docs"]},o="import optimisation",l={unversionedId:"advanced-guide/import-optimisation",id:"version-0.2.0/advanced-guide/import-optimisation",title:"Import Optimisation",description:"Currently CNCH supports the following import methods:",source:"@site/versioned_docs/version-0.2.0/advanced-guide/import-optimisation.mdx",sourceDirName:"advanced-guide",slug:"/advanced-guide/import-optimisation",permalink:"/docs/advanced-guide/import-optimisation",draft:!1,editUrl:"https://github.com/ByConity/byconity.github.io/tree/main/versioned_docs/version-0.2.0/advanced-guide/import-optimisation.mdx",tags:[{label:"Docs",permalink:"/docs/tags/docs"}],version:"0.2.0",frontMatter:{title:"Import Optimisation",tags:["Docs"]},sidebar:"tutorialSidebar",previous:{title:"Complex Query Models and Execution Tuning",permalink:"/docs/advanced-guide/complex-query-model-and-optimisation"},next:{title:"Column ingestion query",permalink:"/docs/advanced-guide/ingest-column"}},s={},u=[{value:"Direct write mode tuning",id:"direct-write-mode-tuning",level:2},{value:"Dumper mode optimisation",id:"dumper-mode-optimisation",level:2}],m={toc:u},c="wrapper";function p(e){let{components:t,...a}=e;return(0,i.kt)(c,(0,r.Z)({},m,a,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("h1",{id:"import-optimisation"},"import optimisation"),(0,i.kt)("h1",{id:"supported-import-methods"},"Supported import methods"),(0,i.kt)("p",null,"Currently CNCH supports the following import methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"INSERT INFILE"),(0,i.kt)("li",{parentName:"ul"},"It is suitable for the situation where the data file has been generated. In the case of a small amount of data, you can directly read the remote/local data file and import it into CNCH. In the case of a large amount of data (more than a few GB), it is recommended to use PartWriter and Attach."),(0,i.kt)("li",{parentName:"ul"},"INSERT VALUES"),(0,i.kt)("li",{parentName:"ul"},"Suitable for temporarily inserting a small amount of data for testing\n-INSERT SELECT"),(0,i.kt)("li",{parentName:"ul"},"Suitable for situations where you need to save the results of a certain table for subsequent queries\n-Dumper&Attach"),(0,i.kt)("li",{parentName:"ul"},"Suitable for migrating from the local version to CNCH, you can directly use Dumper to write the data of the entire cluster into HDFS, and then use Attach to move these data directly to CNCH and query them\n-PartWriter&Attach"),(0,i.kt)("li",{parentName:"ul"},"For scenarios with a large amount of data and a large number of files, tasks such as Spark can be used to use PartWriter to generate new Part files from the original files and write them to HDFS, and then the Attach function can be used to move the data to CNCH for query")),(0,i.kt)("h1",{id:"optimisation-means"},"optimisation means"),(0,i.kt)("h2",{id:"direct-write-mode-tuning"},"Direct write mode tuning"),(0,i.kt)("p",null,"When using INSERT VALUES, INSERT INFILE, or PartWriter tools to write data, the number of Parts generated at the end can affect the number of times data is written to HDFS, which in turn affects the overall writing time. Therefore, it is recommended to minimize the number of Parts generated. The direct writing process is as follows:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"read part of file data"),(0,i.kt)("li",{parentName:"ul"},"Split this part of data according to PartitionBy"),(0,i.kt)("li",{parentName:"ul"},"Split this part of data according to ClusterBy"),(0,i.kt)("li",{parentName:"ul"},"Write the split data into a new Part and write it to HDFS")),(0,i.kt)("p",null,"Optimisation means:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"To reduce the number of Parts, data with the same partition and bucket should be arranged together in a file. This ensures that the number of Parts generated is as small as possible when reading new data. The data can be sorted based on the requirement that the partitions are the same and the buckets in the partitions are the same. The calculation rules for the buckets are as follows:")),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"If SPLIT_NUMBER is not specified, SipHash will be calculated for the column used by ClusterByKey and then the BucketNumber will be moduloed to get BucketNumber"),(0,i.kt)("li",{parentName:"ul"},"if SPLIT_NUMBER is specified"),(0,i.kt)("li",{parentName:"ul"},"Calculate SplitValue"),(0,i.kt)("li",{parentName:"ul"},"If a column is ClusterBy, use the dtspartition function to calculate the corresponding SplitValue"),(0,i.kt)("li",{parentName:"ul"},"If ClusterBy has multiple columns, use SipHash to calculate the corresponding SplitValue of these columns"),(0,i.kt)("li",{parentName:"ul"},"Calculate BucketNumber"),(0,i.kt)("li",{parentName:"ul"},"If it is WithRange, use SplitValue ","*"," BucketCount / SplitNumber to calculate the corresponding BucketNumber"),(0,i.kt)("li",{parentName:"ul"},"If not WithRange, use SplitValue % BucketCount to calculate the corresponding BucketNumber")),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"When reading a file"),(0,i.kt)("li",{parentName:"ol"},"If the data size of each row is not large, you can read a larger block at a time by increasing max_insert_block_size, thereby generating a larger Part"),(0,i.kt)("li",{parentName:"ol"},"If the file to be read is not HDFS/CFS and multiple files are matched using wildcards, you can also increase min_insert_block_size_rows and min_insert_block_size_bytes at the same time")),(0,i.kt)("h2",{id:"dumper-mode-optimisation"},"Dumper mode optimisation"),(0,i.kt)("p",null,"During Dumper migration, you can specify a table and some of its partitions at a time and write them to HDFS. The amount of time required for this process depends on the data size of the table and the number of parts. To increase the concurrency of uploading parts, you can use the parallel parameter. It is also possible to wait for the parts to be merged locally before using Dumper to upload them."))}p.isMDXComponent=!0}}]);