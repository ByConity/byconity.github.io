"use strict";(self.webpackChunkbyconity=self.webpackChunkbyconity||[]).push([[7978],{9613:(e,t,n)=>{n.d(t,{Zo:()=>d,kt:()=>g});var r=n(9496);function o(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function a(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var r=Object.getOwnPropertySymbols(e);t&&(r=r.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,r)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?a(Object(n),!0).forEach((function(t){o(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):a(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,r,o=function(e,t){if(null==e)return{};var n,r,o={},a=Object.keys(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||(o[n]=e[n]);return o}(e,t);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);for(r=0;r<a.length;r++)n=a[r],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(o[n]=e[n])}return o}var c=r.createContext({}),l=function(e){var t=r.useContext(c),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},d=function(e){var t=l(e.components);return r.createElement(c.Provider,{value:t},e.children)},p="mdxType",m={inlineCode:"code",wrapper:function(e){var t=e.children;return r.createElement(r.Fragment,{},t)}},u=r.forwardRef((function(e,t){var n=e.components,o=e.mdxType,a=e.originalType,c=e.parentName,d=s(e,["components","mdxType","originalType","parentName"]),p=l(n),u=o,g=p["".concat(c,".").concat(u)]||p[u]||m[u]||a;return n?r.createElement(g,i(i({ref:t},d),{},{components:n})):r.createElement(g,i({ref:t},d))}));function g(e,t){var n=arguments,o=t&&t.mdxType;if("string"==typeof e||o){var a=n.length,i=new Array(a);i[0]=u;var s={};for(var c in t)hasOwnProperty.call(t,c)&&(s[c]=t[c]);s.originalType=e,s[p]="string"==typeof e?e:o,i[1]=s;for(var l=2;l<a;l++)i[l]=n[l];return r.createElement.apply(null,i)}return r.createElement.apply(null,n)}u.displayName="MDXCreateElement"},2319:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>i,default:()=>m,frontMatter:()=>a,metadata:()=>s,toc:()=>l});var r=n(4778),o=(n(9496),n(9613));const a={title:"Data Compression",sidebar_position:4,tags:["Docs"]},i="Data Compression",s={unversionedId:"table-design/data-compression",id:"table-design/data-compression",title:"Data Compression",description:"ByConity supports codecs for lists, which are methods for compressing and decompressing data aimed at saving storage space and improving I/O performance.",source:"@site/docs/table-design/data-compression.mdx",sourceDirName:"table-design",slug:"/table-design/data-compression",permalink:"/docs/table-design/data-compression",draft:!1,editUrl:"https://github.com/ByConity/byconity.github.io/tree/main/docs/table-design/data-compression.mdx",tags:[{label:"Docs",permalink:"/docs/tags/docs"}],version:"current",sidebarPosition:4,frontMatter:{title:"Data Compression",sidebar_position:4,tags:["Docs"]},sidebar:"tutorialSidebar",previous:{title:"Indexes",permalink:"/docs/table-design/indexes"},next:{title:"External Tables",permalink:"/docs/data-lakes/hive-external-table"}},c={},l=[{value:"General Encodings",id:"general-encodings",level:2},{value:"Special Encodings",id:"special-encodings",level:2},{value:"Best Practices",id:"best-practices",level:2}],d={toc:l},p="wrapper";function m(e){let{components:t,...n}=e;return(0,o.kt)(p,(0,r.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("h1",{id:"data-compression"},"Data Compression"),(0,o.kt)("p",null,"ByConity supports codecs for lists, which are methods for compressing and decompressing data aimed at saving storage space and improving I/O performance."),(0,o.kt)("h2",{id:"general-encodings"},"General Encodings"),(0,o.kt)("p",null,"ByConity supports four general encodings: lz4, lz4hc, zstd, and deflate_qpl. Among them, lz4 belongs to the fast compression algorithm, and its compression efficiency is not its main goal. Therefore, its compression ratio is lower than that of zstd. Intel's IAA (Intel Advanced Analytics) platform supports qpl encoding, so you can consider using qpl on this platform. Links to the documentation provide detailed references for the encodings."),(0,o.kt)("h2",{id:"special-encodings"},"Special Encodings"),(0,o.kt)("p",null,"ByConity also supports several special encodings that can be used together with general encodings, including Delta, DoubleDelta, Gorilla, FPC, and T64. Among them, DoubleDelta encoding can be considered for time series data, and Gorilla encoding can be considered for values that change over time. FPC encoding works well for 64-bit floating-point numbers. T64 encoding finds the common high bits of 64 values and trims them, only recording the changing parts."),(0,o.kt)("h2",{id:"best-practices"},"Best Practices"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"For DateTime type (unsorted), it is recommended to use Delta+LZ4."),(0,o.kt)("li",{parentName:"ul"},"For DateTime type (sorted), LZ4 is recommended."),(0,o.kt)("li",{parentName:"ul"},"For Date type (unsorted), ZSTD is recommended."),(0,o.kt)("li",{parentName:"ul"},"For Date type (sorted, e.g., PK), LZ4 is recommended.")))}m.isMDXComponent=!0}}]);