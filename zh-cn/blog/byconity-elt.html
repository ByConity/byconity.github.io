<!doctype html>
<html lang="zh-cn" dir="ltr" class="blog-wrapper blog-post-page plugin-blog plugin-id-default">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v2.3.1">
<title data-rh="true">ByConity ELT原理详解 | ByConity</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://byconity.github.io/zh-cn/img/byconity-social-card.png"><meta data-rh="true" name="twitter:image" content="https://byconity.github.io/zh-cn/img/byconity-social-card.png"><meta data-rh="true" property="og:url" content="https://byconity.github.io/zh-cn/blog/byconity-elt"><meta data-rh="true" name="docusaurus_locale" content="zh-cn"><meta data-rh="true" name="docusaurus_tag" content="default"><meta data-rh="true" name="docsearch:language" content="zh-cn"><meta data-rh="true" name="docsearch:docusaurus_tag" content="default"><meta data-rh="true" property="og:title" content="ByConity ELT原理详解 | ByConity"><meta data-rh="true" name="description" content="背景"><meta data-rh="true" property="og:description" content="背景"><meta data-rh="true" property="og:type" content="article"><meta data-rh="true" property="article:published_time" content="2023-09-10T00:00:00.000Z"><meta data-rh="true" property="article:author" content="https://github.com/WangTaoTheTonic,https://github.com/tigerwangyb"><meta data-rh="true" property="article:tag" content="video introduction,docusaurus"><link data-rh="true" rel="icon" href="/zh-cn/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://byconity.github.io/zh-cn/blog/byconity-elt"><link data-rh="true" rel="alternate" href="https://byconity.github.io/blog/byconity-elt" hreflang="en"><link data-rh="true" rel="alternate" href="https://byconity.github.io/zh-cn/blog/byconity-elt" hreflang="zh-cn"><link data-rh="true" rel="alternate" href="https://byconity.github.io/blog/byconity-elt" hreflang="x-default"><link data-rh="true" rel="preconnect" href="https://Y8UJSN6KEB-dsn.algolia.net" crossorigin="anonymous"><link rel="alternate" type="application/rss+xml" href="/zh-cn/blog/rss.xml" title="ByConity RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/zh-cn/blog/atom.xml" title="ByConity Atom Feed">

<link rel="preconnect" href="https://www.google-analytics.com">
<link rel="preconnect" href="https://www.googletagmanager.com">
<script async src="https://www.googletagmanager.com/gtag/js?id=G-BYY7CCPJZ6"></script>
<script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","G-BYY7CCPJZ6",{})</script>


<link rel="search" type="application/opensearchdescription+xml" title="ByConity" href="/zh-cn/opensearch.xml"><link rel="stylesheet" href="/zh-cn/assets/css/styles.d2f68745.css">
<link rel="preload" href="/zh-cn/assets/js/runtime~main.65e2f61b.js" as="script">
<link rel="preload" href="/zh-cn/assets/js/main.824f059c.js" as="script">
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){var t=null;try{t=localStorage.getItem("theme")}catch(t){}return t}();t(null!==e?e:"light")}()</script><div id="__docusaurus">
<div role="region" aria-label="跳到主要内容"><a class="skipToContent_Rzz1" href="#docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top navbarHideable_hfek"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/zh-cn/"><div class="navbar__logo"><img src="/zh-cn/img/logo.png" alt="ByConity Logo" class="themedImage_DeRy themedImage--light_hbln"><img src="/zh-cn/img/logo.png" alt="ByConity Logo" class="themedImage_DeRy themedImage--dark_qgR1"></div><b class="navbar__title text--truncate">ByConity</b></a><a class="navbar__item navbar__link" href="/zh-cn/docs/introduction/what-is-byconity">文档</a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/zh-cn/blog">博客</a><a class="navbar__item navbar__link" href="/zh-cn/community/become-maintainer">社区</a><a class="navbar__item navbar__link" href="/zh-cn/users">用户</a></div><div class="navbar__items navbar__items--right"><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a class="navbar__link" aria-haspopup="true" aria-expanded="false" role="button" href="/zh-cn/docs/introduction/what-is-byconity">0.3.x</a><ul class="dropdown__menu"><li><a class="dropdown__link" href="/zh-cn/docs/introduction/what-is-byconity">0.3.x</a></li><li><a class="dropdown__link" href="/zh-cn/docs/0.2.0/introduction/main-principle-concepts">0.2.0</a></li></ul></div><div class="navbar__item dropdown dropdown--hoverable dropdown--right"><a href="#" aria-haspopup="true" aria-expanded="false" role="button" class="navbar__link">中文（中国）</a><ul class="dropdown__menu"><li><a href="/blog/byconity-elt" target="_self" rel="noopener noreferrer" class="dropdown__link" lang="en">English</a></li><li><a href="/zh-cn/blog/byconity-elt" target="_self" rel="noopener noreferrer" class="dropdown__link dropdown__link--active" lang="zh-cn">中文（中国）</a></li></ul></div><a href="https://github.com/ByConity/ByConity" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link header-github-link"><span>GitHub</span></a><div class="searchBox_mmj0"><button type="button" class="DocSearch DocSearch-Button" aria-label="搜索"><span class="DocSearch-Button-Container"><svg width="20" height="20" class="DocSearch-Search-Icon" viewBox="0 0 20 20"><path d="M14.386 14.386l4.0877 4.0877-4.0877-4.0877c-2.9418 2.9419-7.7115 2.9419-10.6533 0-2.9419-2.9418-2.9419-7.7115 0-10.6533 2.9418-2.9419 7.7115-2.9419 10.6533 0 2.9419 2.9418 2.9419 7.7115 0 10.6533z" stroke="currentColor" fill="none" fill-rule="evenodd" stroke-linecap="round" stroke-linejoin="round"></path></svg><span class="DocSearch-Button-Placeholder">搜索</span></span><span class="DocSearch-Button-Keys"></span></button></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_NWrx"><div class="container margin-vert--lg"><div class="row"><aside class="col col--3"><nav class="sidebar_J5VD thin-scrollbar" aria-label="最近博文导航"><div class="sidebarItemTitle_ZkTY margin-bottom--md">Recent posts</div><ul class="sidebarItemList_Jaez clean-list"><li class="sidebarItem_mMbS"><a aria-current="page" class="sidebarItemLink_LJmi sidebarItemLinkActive_nl4s" href="/zh-cn/blog/byconity-elt">ByConity ELT原理详解</a></li><li class="sidebarItem_mMbS"><a class="sidebarItemLink_LJmi" href="/zh-cn/blog/byconity-benchmark">ByConity与主流开源OLAP引擎（Clickhouse、Doris、Presto）性能对比分析</a></li><li class="sidebarItem_mMbS"><a class="sidebarItemLink_LJmi" href="/zh-cn/blog/2023-05-24-byconity-announcement-opensources-its-cloudnative-data-warehouse">ByteDance Open Sources Its Cloud Native Data Warehouse ByConity</a></li><li class="sidebarItem_mMbS"><a class="sidebarItemLink_LJmi" href="/zh-cn/blog/byconity-an-opensource-cloudnative-data-warehouse-post">ByConity -- An Open source Cloud-native Data Warehouse</a></li></ul></nav></aside><main class="col col--7" itemscope="" itemtype="http://schema.org/Blog"><article itemprop="blogPost" itemscope="" itemtype="http://schema.org/BlogPosting"><header><h1 class="title_XMSB" itemprop="headline">ByConity ELT原理详解</h1><div class="container_fJtn margin-vert--md"><time datetime="2023-09-10T00:00:00.000Z" itemprop="datePublished">2023年9月10日</time> · <!-- -->阅读需 15 分钟</div><div class="margin-top--md margin-bottom--sm row"><div class="col col--6 authorCol_YzU5"><div class="avatar margin-bottom--sm"><a href="https://github.com/WangTaoTheTonic" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/WangTaoTheTonic.png" alt="Tao Wang"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/WangTaoTheTonic" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Tao Wang</span></a></div><small class="avatar__subtitle" itemprop="description">ByConity maintainer</small></div></div></div><div class="col col--6 authorCol_YzU5"><div class="avatar margin-bottom--sm"><a href="https://github.com/tigerwangyb" target="_blank" rel="noopener noreferrer" class="avatar__photo-link"><img class="avatar__photo" src="https://github.com/tigerwangyb.png" alt="Yunbo Wang"></a><div class="avatar__intro" itemprop="author" itemscope="" itemtype="https://schema.org/Person"><div class="avatar__name"><a href="https://github.com/tigerwangyb" target="_blank" rel="noopener noreferrer" itemprop="url"><span itemprop="name">Yunbo Wang</span></a></div><small class="avatar__subtitle" itemprop="description">ByConity maintainer</small></div></div></div></div></header><div id="post-content" class="markdown" itemprop="articleBody"><h2 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="背景">背景<a href="#背景" class="hash-link" aria-label="背景的直接链接" title="背景的直接链接">​</a></h2><p>谈到数据仓库， 一定离不开使用Extract-Transform-Load (ETL)或 Extract-Load-Transform (ELT)。 将来源不同、格式各异的数据提取到数据仓库中，并进行处理加工。传统的数据转换过程一般采用Extract-Transform-Load (ETL)来将业务数据转换为适合数仓的数据模型，然而，这依赖于独立于数仓外的ETL系统，因而维护成本较高。
ByConity 作为云原生数据仓库，从0.2.0版本开始逐步支持 Extract-Load-Transform (ELT)，使用户免于维护多套异构数据系统。本文将介绍 ByConity 在ELT方面的能力规划，实现原理和使用方式等。</p><h2 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="etl场景和方案">ETL场景和方案<a href="#etl场景和方案" class="hash-link" aria-label="ETL场景和方案的直接链接" title="ETL场景和方案的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="elt与etl的区别">ELT与ETL的区别<a href="#elt与etl的区别" class="hash-link" aria-label="ELT与ETL的区别的直接链接" title="ELT与ETL的区别的直接链接">​</a></h3><ul><li>ETL：是用来描述将数据从来源端经过抽取、转置、加载至目的端（数据仓库）的过程。Transform通常描述在数据仓库中的前置数据加工过程。</li></ul><p><img loading="lazy" src="/zh-cn/assets/images/elt1-ccfe04dd9abfa7d620e7c93b024bbc2c.png" width="1080" height="388" class="img_astN"></p><ul><li>ELT 专注于将最小处理的数据加载到数据仓库中，而把大部分的转换操作留给分析阶段。相比起前者（ETL)，它不需要过多的数据建模，而给分析者提供更灵活的选项。ELT已经成为当今大数据的处理常态，它对数据仓库也提出了很多新的要求。</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="资源重复的挑战">资源重复的挑战<a href="#资源重复的挑战" class="hash-link" aria-label="资源重复的挑战的直接链接" title="资源重复的挑战的直接链接">​</a></h3><p><img loading="lazy" src="/zh-cn/assets/images/elt2-caa5b7ef03a16466c984978e04735732.png" width="1048" height="402" class="img_astN"></p><p>典型的数据链路如下：我们将行为数据、日志、点击流等通过MQ/ Kafka/ Flink将其接入存储系统当中，存储系统又可分为域内的HDFS 和云上的 OSS&amp; S3 这种远程储存系统，然后进行一系列的数仓的ETL操作，提供给 OLAP系统完成分析查询。
但有些业务需要从上述的存储中做一个分支，因此会在数据分析的某一阶段，从整体链路中将数据导出，做一些不同于主链路的ETL操作，会出现两份数据存储。其次在这过程中也会出现两套不同的ETL逻辑。
当数据量变大，计算冗余以及存储冗余所带来的成本压力也会愈发变大，同时，存储空间的膨胀也会让弹性扩容变得不便利。</p><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="业界解决思路">业界解决思路<a href="#业界解决思路" class="hash-link" aria-label="业界解决思路的直接链接" title="业界解决思路的直接链接">​</a></h3><p>在业界中，为了解决以上问题，有以下几类流派：</p><ul><li>数据预计算流派：如Kylin等。如果Hadoop系统中出报表较慢或聚合能力较差，可以去做一个数据的预计算，提前将配的指标的cube或一些视图算好。实际SQL查询时，可以直接用里面的cube或视图做替换，之后直接返回。</li><li>流批一体派：如 Flink、Risingwave。在数据流进时，针对一些需要出报表或者需要做大屏的数据直接内存中做聚合。聚合完成后，将结果写入HBase或MySQL中再去取数据，将数据取出后作展示。Flink还会去直接暴露中间状态的接口，即queryable state，让用户更好的使用状态数据。但是最后还会与批计算的结果完成对数，如果不一致，需要进行回查操作，整个过程考验运维/开发同学的功力。</li><li>湖仓一体&amp;HxxP:将数据湖与数据仓库结合起来。</li></ul><h2 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="elt-in-byconity">ELT in ByConity<a href="#elt-in-byconity" class="hash-link" aria-label="ELT in ByConity的直接链接" title="ELT in ByConity的直接链接">​</a></h2><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="整体执行流程">整体执行流程<a href="#整体执行流程" class="hash-link" aria-label="整体执行流程的直接链接" title="整体执行流程的直接链接">​</a></h3><p><img loading="lazy" src="/zh-cn/assets/images/elt3-9500640cd18aa26d9bc3357e5dd627c9.png" width="1280" height="828" class="img_astN"></p><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="elt任务对系统的要求">ELT任务对系统的要求：<a href="#elt任务对系统的要求" class="hash-link" aria-label="ELT任务对系统的要求：的直接链接" title="ELT任务对系统的要求：的直接链接">​</a></h3><ol><li>整体易扩展：导入和转换通常需要大量的资源，系统需要通过水平扩展的方式来满足数据量的快速增长。</li><li>可靠性和容错能力：大量的job能有序调度；出现task偶然失败（OOM）、container失败时，能够拉起重试；能处理一定的数据倾斜</li><li>效率&amp;性能：有效利用多核多机并发能力；数据快速导入；内存使用有效（内存管理）；CPU优化（向量化、codegen）</li><li>生态&amp;可观测性：可对接多种工具；任务状态感知；任务进度感知；失败日志查询；有一定可视化能力</li></ol><p>ByConity 针对ELT任务的要求，以及当前场景遇到的困难，新增了以下特性和优化改进。</p><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="分阶段执行stage-level-scheduling">分阶段执行（Stage-level Scheduling）<a href="#分阶段执行stage-level-scheduling" class="hash-link" aria-label="分阶段执行（Stage-level Scheduling）的直接链接" title="分阶段执行（Stage-level Scheduling）的直接链接">​</a></h3><p><img loading="lazy" src="/zh-cn/assets/images/elt4-494e04491f26b62b894e7bcea61beb89.png" width="830" height="528" class="img_astN"></p><h4 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="原理解析">原理解析<a href="#原理解析" class="hash-link" aria-label="原理解析的直接链接" title="原理解析的直接链接">​</a></h4><ul><li>当前 ClickHouse的 SQL 执行过程如下：<ul><li>第一阶段，Coordinator 收到分布式表查询后将请求转换为对 local 表查询发送给每个 shard 节点；</li><li>第二阶段，Coordinator 收到各个节点的结果后汇聚起来处理后返回给客户端；</li></ul></li><li>ClickHouse 将Join操作中的右表转换为子查询，带来如下几个问题都很难以解决：<ul><li>复杂的query有多个子查询，转换复杂度高；</li><li>Join表较大时，容易造成worker节点的OOM；</li><li>聚合阶段在Cooridnator，压力大，容易成为性能瓶颈；</li></ul></li></ul><p><img loading="lazy" src="/zh-cn/assets/images/elt5-feb79e6e129f3aeb9ab86aa2b92767f4.png" width="443" height="521" class="img_astN"> <img loading="lazy" src="/zh-cn/assets/images/elt6-8481e54f07ead8899937be2f068395c6.png" width="395" height="536" class="img_astN"> <img loading="lazy" src="/zh-cn/assets/images/elt7-306fde6a5dad86ac0bb435ce6909f7bc.png" width="320" height="231" class="img_astN"></p><p>不同于ClickHouse，我们在ByConity 中实现了对复杂查询的执行优化。通过对执行计划的切分，将之前的两阶段执行模型转换为分阶段执行。在逻辑计划阶段，根据算子类型插入exchange算子。执行阶段根据exchange算子将整个执行计划进行DAG切分，并且分stage进行调度。stage之间的exchange算子负责完成数据传输和交换。
关键节点：</p><ol><li>exchange节点插入</li><li>切分stage</li><li>stage scheduler</li><li>segment executer</li><li>exchange manager</li></ol><p><img loading="lazy" src="/zh-cn/assets/images/elt8-91b30f3fc765792bb11ada8747fd2ec2.png" width="583" height="529" class="img_astN"></p><p>这里重点来讲一下exchange的视线。上图可以看到，最顶层的是query plan。下面转换成物理计划的时候，我们会根据不同的数据分布的要求转换成不同的算子。source层是接收数据的节点，基本都是统一的，叫做ExchangeSource。Sink则有不同的实现，BroadcastSink、Local、PartitionSink等，他们是作为map task的一部分去运行的。如果是跨节点的数据操作，我们在底层使用统一的brpc流式数据传输，如果是本地，则使用内存队列来实现。针对不同的点，我们进行了非常细致的优化：</p><ul><li>数据传输层<ul><li>进程内通过内存队列，无序列化，zero copy</li><li>进程间使用brpc stream rpc，保序、连接复用、状态码传输、压缩等</li></ul></li><li>算子层<ul><li>批量发送</li><li>线程复用，减少线程数量</li></ul></li></ul><h4 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="带来的收益">带来的收益<a href="#带来的收益" class="hash-link" aria-label="带来的收益的直接链接" title="带来的收益的直接链接">​</a></h4><p>因为ByConity 彻底采用了多阶段的查询执行方式，整体有很大的收益：</p><ul><li>Cooridnator更稳定、更高效<ul><li>聚合等算子拆分到worker节点执行</li><li>Cooridnator节点只需要聚合最终结果</li></ul></li><li>Worker OOM减少<ul><li>进行了stage切分，每个stage的计算相对简单</li><li>增加了exchange算子，减少内存压力</li></ul></li><li>网络连接更加稳定、高效<ul><li>exchange算子有效传输</li><li>复用连接池</li></ul></li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="自适应的调度器adaptive-scheduler">自适应的调度器（Adaptive Scheduler）<a href="#自适应的调度器adaptive-scheduler" class="hash-link" aria-label="自适应的调度器（Adaptive Scheduler）的直接链接" title="自适应的调度器（Adaptive Scheduler）的直接链接">​</a></h3><p>Adaptive Scheduler 属于我们在稳定性方面所做的特性。在OLAP场景中可能会发现部分数据不全或数据查询超时等，原因是每个worker是所有的query共用的，这样一旦有一个worker 较慢就会导致整个query的执行受到影响。</p><p><img loading="lazy" src="/zh-cn/assets/images/elt9-5832a9a799604adcf46d919e33a0fd48.png" width="360" height="360" class="img_astN"></p><p>计算节点共用存在的问题：</p><ul><li>Scan 所在的节点负载和不同查询所需的扫描数据量相关，做不到完全平均；</li><li>各 Plan Segment 所需资源差异大；
这就导致worker节点之间的负载严重不均衡。负载较重的worker节点就会影响query整体的进程。因此我们做了以下的优化方案：</li><li>建立 Worker 健康度机制。Server 端建立 Worker 健康度管理类，可以快速获取 Worker Group 的健康度信息，包括CPU、内存、运行Query数量等信息。</li><li>自适应调度：每个SQL 根据 Worker 健康度动态的进行选择以及计算节点并发度控制。</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="查询的队列机制query-queue">查询的队列机制（Query Queue）<a href="#查询的队列机制query-queue" class="hash-link" aria-label="查询的队列机制（Query Queue）的直接链接" title="查询的队列机制（Query Queue）的直接链接">​</a></h3><p><img loading="lazy" src="/zh-cn/assets/images/elt10-00e36ff14589366f30019c9a22871ed0.png" width="1280" height="1024" class="img_astN"> <img loading="lazy" src="/zh-cn/assets/images/elt11-7a76adabaa507e6b8502fef8764e9333.png" width="1280" height="1047" class="img_astN"></p><p>我们的集群也会出现满载情况，即所有的worker都是不健康的或者满载/超载的，就会用查询队列来进行优化。
我们直接在server端做了一个manager。每次查询的时候manager会去check集群的资源，并且持有一个锁。如果资源不够用，则等待资源释放后去唤醒这个锁。这就避免了Server端不限制的下发计算任务，导致worker节点超载，然后崩掉的情况。
当前实现相对简单。server是多实例，每个server实例中都有queue，所持有的是一个局部视角，缺乏全局的资源视角。除此之外，每个queue中的查询状态没有持久化，只是简单的缓存在内存中。
后续，我们会增加server之间的协调，在一个全局的视角上对查询并发做限制。也会对server实例中query做持久化，增加一些failover的场景支持。</p><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="异步执行async-execution">异步执行（Async Execution）<a href="#异步执行async-execution" class="hash-link" aria-label="异步执行（Async Execution）的直接链接" title="异步执行（Async Execution）的直接链接">​</a></h3><p><img loading="lazy" src="/zh-cn/assets/images/elt12-8734ea2851ceceb9d629659aecd68ac5.png" width="1280" height="708" class="img_astN"></p><p>ELT任务的一个典型特征就是：相对于即时分析，他们的运行时间会相对较长。一般ELT任务执行时长为分钟级，甚至到达小时级。
目前 ClickHouse的客户端查询都采用阻塞的方式进行返回。这样就造成了客户端长期处于等待的情况，而在这个等待过程中还需要保持和服务端的连接。在不稳定的网络情况下，客户端和服务端的连接会断开，从而导致服务端的任务失败。
为了减少这种不必要的失败，以及减少客户端为了维持连接的增加的复杂度。我们开发了异步执行的功能，它的实现如下：</p><ol><li>用户指定异步执行。用户可以通过settings enable_async_query = 1的方式进行per query的指定。也可以通过set enable_async_query = 1的方式进行session级别的指定。</li><li>如果是异步query，则将其放到后台线程池中运行</li><li>静默io。当异步query执行时，则需要切断它和客户端的交互逻辑，比如输出日志等。</li></ol><p>针对query的初始化还是在session的同步线程中进行。一旦完成初始化，则将query状态写入到metastore，并向客户端返回async query id。客户端可以用这个id查询query的状态。async query id返回后，则表示完成此次查询的交互。这种模式下，如果语句是select，那么后续结果则无法回传给客户端。这种情况下我们推荐用户使用async query + select...into outfile的组合来满足需求。</p><h2 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="未来规划">未来规划<a href="#未来规划" class="hash-link" aria-label="未来规划的直接链接" title="未来规划的直接链接">​</a></h2><p>针对ELT混合负载，ByConity 0.2.0版本目前只是牛刀小试。后续的版本中我们会持续优化查询相关的能力，ELT为核心的规划如下：</p><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="故障恢复能力">故障恢复能力<a href="#故障恢复能力" class="hash-link" aria-label="故障恢复能力的直接链接" title="故障恢复能力的直接链接">​</a></h3><ul><li>算子Spill<ul><li>Sort、Agg、Join 算子Spill；</li><li>Exchange Spill 能力；</li></ul></li><li>Recoverability 容错恢复<ul><li>算子执行恢复：ELT任务运行时长较长时，中间 Task的偶发失败会导致整个Query失败，支持Task 级别重试可以极大地降低环境原因导致的偶发失败；</li><li>Stage重试：当节点失败时，可以进行 Stage级别的重试；</li><li>保存队列作业状态的能力；</li></ul></li><li>Remote Shuffle Service：当前业界开源的 shuffle service通常为Spark定制，没有通用的客户端，比如c++客户端。后续我们会补充这部分能力。</li></ul><h3 class="anchor anchorWithHideOnScrollNavbar_l3HI" id="资源">资源<a href="#资源" class="hash-link" aria-label="资源的直接链接" title="资源的直接链接">​</a></h3><ul><li>计算资源可指定：用户可指定query需要的计算资源；</li><li>计算资源预估/预占：可动态预估query需要的计算资源，并通过预占的方式进行调配；</li><li>动态申请资源：当前worker均为常驻进程/节点。动态申请资源可以提高利用率；</li><li>更细粒度的资源隔离：通过worker group或者进程级别的隔离，减少各query之间相互影响；</li></ul></div><footer class="row docusaurus-mt-lg blogPostFooterDetailsFull_Vbb7"><div class="col"><b>标签：</b><ul class="tags_HAaO padding--none margin-left--sm"><li class="tag_Ut5_"><a class="tag_sQub tagRegular_dfhI" href="/zh-cn/blog/tags/video-introduction">video introduction</a></li><li class="tag_Ut5_"><a class="tag_sQub tagRegular_dfhI" href="/zh-cn/blog/tags/docusaurus">docusaurus</a></li></ul></div><div class="col margin-top--sm"><a href="https://github.com/ByConity/byconity.github.io/tree/main/i18n/zh-cn/docusaurus-plugin-content-blog/2023-09-10-byconity-elt/index.md" target="_blank" rel="noreferrer noopener" class="theme-edit-this-page"><svg fill="currentColor" height="20" width="20" viewBox="0 0 40 40" class="iconEdit_O9Og" aria-hidden="true"><g><path d="m34.5 11.7l-3 3.1-6.3-6.3 3.1-3q0.5-0.5 1.2-0.5t1.1 0.5l3.9 3.9q0.5 0.4 0.5 1.1t-0.5 1.2z m-29.5 17.1l18.4-18.5 6.3 6.3-18.4 18.4h-6.3v-6.2z"></path></g></svg>编辑此页</a></div></footer></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="博文分页导航"><a class="pagination-nav__link pagination-nav__link--next" href="/zh-cn/blog/byconity-benchmark"><div class="pagination-nav__sublabel">较旧一篇</div><div class="pagination-nav__label">ByConity与主流开源OLAP引擎（Clickhouse、Doris、Presto）性能对比分析</div></a></nav></main><div class="col col--2"><div class="tableOfContents_Q7NC thin-scrollbar"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#背景" class="table-of-contents__link toc-highlight">背景</a></li><li><a href="#etl场景和方案" class="table-of-contents__link toc-highlight">ETL场景和方案</a><ul><li><a href="#elt与etl的区别" class="table-of-contents__link toc-highlight">ELT与ETL的区别</a></li><li><a href="#资源重复的挑战" class="table-of-contents__link toc-highlight">资源重复的挑战</a></li><li><a href="#业界解决思路" class="table-of-contents__link toc-highlight">业界解决思路</a></li></ul></li><li><a href="#elt-in-byconity" class="table-of-contents__link toc-highlight">ELT in ByConity</a><ul><li><a href="#整体执行流程" class="table-of-contents__link toc-highlight">整体执行流程</a></li><li><a href="#elt任务对系统的要求" class="table-of-contents__link toc-highlight">ELT任务对系统的要求：</a></li><li><a href="#分阶段执行stage-level-scheduling" class="table-of-contents__link toc-highlight">分阶段执行（Stage-level Scheduling）</a></li><li><a href="#自适应的调度器adaptive-scheduler" class="table-of-contents__link toc-highlight">自适应的调度器（Adaptive Scheduler）</a></li><li><a href="#查询的队列机制query-queue" class="table-of-contents__link toc-highlight">查询的队列机制（Query Queue）</a></li><li><a href="#异步执行async-execution" class="table-of-contents__link toc-highlight">异步执行（Async Execution）</a></li></ul></li><li><a href="#未来规划" class="table-of-contents__link toc-highlight">未来规划</a><ul><li><a href="#故障恢复能力" class="table-of-contents__link toc-highlight">故障恢复能力</a></li><li><a href="#资源" class="table-of-contents__link toc-highlight">资源</a></li></ul></li></ul></div></div></div></div></div><footer class="footer footer--dark"><div class="container"><div class="row"><div class="col col--3"><img src="/zh-cn/img/footer-logo.svg" alt="ByConity" class="themedImage_DeRy themedImage--light_hbln footer__logo"><img src="/zh-cn/img/footer-logo.svg" alt="ByConity" class="themedImage_DeRy themedImage--dark_qgR1 footer__logo"></div><div class="col"><div class="row footer__links"><div class="col footer__col"><div class="footer__title">文档</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/zh-cn/docs/introduction/main-principle-concepts">文档</a></li></ul></div><div class="col footer__col"><div class="footer__title">社区</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/zh-cn/community">Community</a></li><li class="footer__item"><a class="footer__link-item" href="/zh-cn/users">用户</a></li><li class="footer__item"><a href="https://space.bilibili.com/2065226922?spm_id_from=333.1007.0.0" target="_blank" rel="noopener noreferrer" class="footer__link-item">B站<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_LBPb"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div><div class="col footer__col"><div class="footer__title">更多</div><ul class="footer__items clean-list"><li class="footer__item"><a class="footer__link-item" href="/zh-cn/blog">博客</a></li><li class="footer__item"><a href="https://github.com/ByConity/ByConity" target="_blank" rel="noopener noreferrer" class="footer__link-item">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_LBPb"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a></li></ul></div></div></div></div><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2023 ByteDance.</div></div></div></footer></div>
<script src="/zh-cn/assets/js/runtime~main.65e2f61b.js"></script>
<script src="/zh-cn/assets/js/main.824f059c.js"></script>
</body>
</html>