<hr>
<h2 id="title-“Aggregation”slug-“aggregate”hidden-falsemetadata-title-“Aggregation-Functions-in-ByteHouse”-description-“Find-out-various-aggregation-functions-supported-in-ByteHouse-such-as-anyHeavy-anyLast-argMax-argMin-avg-corr-covarPop-covarSamp-groupBitAnd-etc-”createdAt-“2021-07-29T11-49-53-230Z”updatedAt-“2021-09-23T03-25-11-849Z”categories-Docs-SQL-Syntaxtags-Docs"><a href="#title-“Aggregation”slug-“aggregate”hidden-falsemetadata-title-“Aggregation-Functions-in-ByteHouse”-description-“Find-out-various-aggregation-functions-supported-in-ByteHouse-such-as-anyHeavy-anyLast-argMax-argMin-avg-corr-covarPop-covarSamp-groupBitAnd-etc-”createdAt-“2021-07-29T11-49-53-230Z”updatedAt-“2021-09-23T03-25-11-849Z”categories-Docs-SQL-Syntaxtags-Docs" class="headerlink" title="title: “Aggregation”slug: “aggregate”hidden: falsemetadata:  title: “Aggregation Functions in ByteHouse”  description: “Find out various aggregation functions supported in ByteHouse such as anyHeavy, anyLast, argMax, argMin, avg, corr, covarPop, covarSamp, groupBitAnd, etc.”createdAt: “2021-07-29T11:49:53.230Z”updatedAt: “2021-09-23T03:25:11.849Z”categories:- Docs- SQL_Syntaxtags:- Docs"></a>title: “Aggregation”<br>slug: “aggregate”<br>hidden: false<br>metadata:<br>  title: “Aggregation Functions in ByteHouse”<br>  description: “Find out various aggregation functions supported in ByteHouse such as anyHeavy, anyLast, argMax, argMin, avg, corr, covarPop, covarSamp, groupBitAnd, etc.”<br>createdAt: “2021-07-29T11:49:53.230Z”<br>updatedAt: “2021-09-23T03:25:11.849Z”<br>categories:<br>- Docs<br>- SQL_Syntax<br>tags:<br>- Docs</h2><blockquote>
<p>Notice:<br>Some of the examples below are referenced from <a href="https://clickhouse.com/docs/en/sql-reference/functions/">ClickHouse Documentation</a> but have been adapted and modified to work in ByteHouse.</p>
</blockquote>
<h2 id="any"><a href="#any" class="headerlink" title="any"></a>any</h2><p>Selects the first encountered value.<br>The query can be executed in any order and even in a different order each time, so the result of this function is indeterminate.<br>To get a determinate result, you can use the ‘min’ or ‘max’ function instead of ‘any’.</p>
<p>In some cases, you can rely on the order of execution. This applies to cases when SELECT comes from a subquery that uses ORDER BY.</p>
<p>When a <code>SELECT</code> query has the <code>GROUP BY</code> clause or at least one aggregate function, ByteHouse (in contrast to MySQL) requires that all expressions in the <code>SELECT</code> , <code>HAVING</code> , and <code>ORDER BY</code> clauses be calculated from keys or from aggregate functions. In other words, each column selected from the table must be used either in keys or inside aggregate functions. To get behavior like in MySQL, you can put the other columns in the <code>any</code> aggregate function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">any(column)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>column</code> – The column name.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>first value encontered. Type is same as input column.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT any(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─any(number)─┐
│ 0           │
└─────────────┘
</code></pre>
<h2 id="anyHeavy"><a href="#anyHeavy" class="headerlink" title="anyHeavy"></a>anyHeavy</h2><p>Selects a frequently occurring value using the <a href="http://www.cs.umd.edu/~samir/498/karp.pdf">heavy hitters</a> algorithm. If there is a value that occurs more than in half the cases in each of the query’s execution threads, this value is returned. Normally, the result is nondeterministic.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">anyHeavy(column)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>column</code> – The column name.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>most frequent value. Type is same as input column.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionAnyHeavy(id Int) ENGINE=CnchMergeTree() ORDER BY id;
INSERT INTO test.functionAnyHeavy values (1),(1),(1),(2),(3);
SELECT anyHeavy(id) FROM test.functionAnyHeavy;
</code></pre>
<pre><code class="plain%20text">┌─anyHeavy(id)─┐
│ 1            │
└──────────────┘
</code></pre>
<h2 id="anyLast"><a href="#anyLast" class="headerlink" title="anyLast"></a>anyLast</h2><p>Selects the last value encountered.<br>The result is just as indeterminate.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">anyLast(column)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>column</code> – The column name.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>last value encountered. Type is same as input column.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT anyLast(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─anyLast(number)─┐
│ 9               │
└─────────────────┘
</code></pre>
<h2 id="argMax"><a href="#argMax" class="headerlink" title="argMax"></a>argMax</h2><p>Calculates the <code>arg</code> value for a maximum <code>val</code> value. If there are several different values of <code>arg</code> for maximum values of <code>val</code> , returns the first of these values encountered.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">argMax(arg, val)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arg</code> — Argument. </li>
<li><code>val</code> — Value.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>arg value that corresponds to maximum val value. Type is same as arg type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionArgMax (user String, salary Int) Engine=CnchMergeTree() ORDER BY user;
INSERT INTO test.functionArgMax VALUES (&#39;director&#39;,5000),(&#39;manager&#39;,3000),(&#39;worker&#39;,1000);
SELECT argMax(user, salary) FROM test.functionArgMax;
</code></pre>
<pre><code class="plain%20text">┌─argMax(user, salary)─┐
│ director             │
└──────────────────────┘
</code></pre>
<h2 id="argMin"><a href="#argMin" class="headerlink" title="argMin"></a>argMin</h2><p>Calculates the <code>arg</code> value for a minimum <code>val</code> value. If there are several different values of <code>arg</code> for minimum values of <code>val</code> , returns the first of these values encountered.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">argMin(arg, val)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>arg</code> — Argument. </li>
<li><code>val</code> — Value.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>arg value that corresponds to minimum val value. Type is same as arg type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionArgMin (user String, salary Int) Engine=CnchMergeTree() ORDER BY user;
INSERT INTO test.functionArgMin VALUES (&#39;director&#39;,5000),(&#39;manager&#39;,3000),(&#39;worker&#39;,1000);
SELECT argMin(user, salary) FROM test.functionArgMin;
</code></pre>
<pre><code class="plain%20text">┌─argMin(user, salary)─┐
│ worker               │
└──────────────────────┘
</code></pre>
<h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><p>Calculates the arithmetic mean.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">avg(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code> — input values, must be Integer, Float or Decimal.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>The arithmetic mean, always as Float64. </li>
<li><code>NaN</code> if the input parameter <code>x</code> is empty.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionAvg (x Int8) ENGINE=CnchMergeTree() ORDER BY x;
INSERT INTO test.functionAvg SELECT * FROM numbers(6);
SELECT avg(x) FROM test.functionAvg;
</code></pre>
<pre><code class="plain%20text">┌─avg(x)──┐
│ 2.5e+00 │
└─────────┘
</code></pre>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionAvg (x Int8) ENGINE=CnchMergeTree() ORDER BY x;
SELECT avg(x) FROM test.functionAvg;
</code></pre>
<pre><code class="plain%20text">┌─avg(x)─┐
│ NaN    │
└────────┘
</code></pre>
<h2 id="corr"><a href="#corr" class="headerlink" title="corr"></a>corr</h2><p>Calculates the Pearson correlation coefficient: <code>Σ((x - x̅)(y - y̅)) / sqrt(Σ((x - x̅)^2) * Σ((y - y̅)^2))</code>.<br>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>corrStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">corr(x, y)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code> — input values, must be Integer, Float. </li>
<li><code>y</code> — input values, must be Integer, Float.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Pearson correlation coefficient, always as Float64.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionCorr (x Int8, y Int8) ENGINE=CnchMergeTree() ORDER BY x;
INSERT INTO test.functionCorr VALUES (1,5),(2,4),(3,3),(4,2),(5,1);
SELECT corr(x,y) FROM test.functionCorr;
</code></pre>
<pre><code class="plain%20text">┌─corr(x, y)─┐
│ -1e+00     │
└────────────┘
</code></pre>
<h2 id="covarPop"><a href="#covarPop" class="headerlink" title="covarPop"></a>covarPop</h2><p>Calculates the value of <code>Σ((x - x̅)(y - y̅)) / n</code>.<br>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>covarPopStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">covarPop(x, y)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code> — input values, must be Integer, Float. </li>
<li><code>y</code> — input values, must be Integer, Float.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li><code>Σ((x - x̅)(y - y̅)) / n</code>, always as Float64.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionCovarPop (x Int8, y Int8) ENGINE=CnchMergeTree() ORDER BY x;
INSERT INTO test.functionCovarPop VALUES (1,5),(2,4),(3,3),(4,2),(5,1);
SELECT covarPop(x,y) FROM test.functionCovarPop;
</code></pre>
<pre><code class="plain%20text">┌─covarPop(x, y)─┐
│ -2e+00         │
└────────────────┘
</code></pre>
<h2 id="covarSamp"><a href="#covarSamp" class="headerlink" title="covarSamp"></a>covarSamp</h2><p>Calculates the value of <code>Σ((x - x̅)(y - y̅)) / (n - 1)</code>.<br>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>covarSampStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">covarSamp(x, y)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code> — input values, must be Integer, Float. </li>
<li><code>y</code> — input values, must be Integer, Float.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li><code>Σ((x - x̅)(y - y̅)) / (n - 1)</code>, always as Float64.</li>
<li>When n &lt;&#x3D; 1, returns NaN.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionCovarSamp (x Int8, y Int8) ENGINE=CnchMergeTree() ORDER BY x;
INSERT INTO test.functionCovarSamp VALUES (1,5),(2,4),(3,3),(4,2),(5,1);
SELECT covarSamp(x,y) FROM test.functionCovarSamp;
</code></pre>
<pre><code class="plain%20text">┌─covarSamp(x, y)─┐
│ -2.5e+00        │
└─────────────────┘
</code></pre>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionCovarSamp (x Int8, y Int8) ENGINE=CnchMergeTree() ORDER BY x;
INSERT INTO test.functionCovarSamp VALUES (1,5);
SELECT covarSamp(x,y) FROM test.functionCovarSamp;
</code></pre>
<pre><code class="plain%20text">┌─covarSamp(x, y)─┐
│ NaN             │
└─────────────────┘
</code></pre>
<h2 id="groupArray"><a href="#groupArray" class="headerlink" title="groupArray"></a>groupArray</h2><p>Creates an array of argument values.<br>Values can be added to the array in any (indeterminate) order.</p>
<p>The second version (with the <code>max_size</code> parameter) limits the size of the resulting array to <code>max_size</code> elements. For example, <code>groupArray(1)(x)</code> is equivalent to <code>[any (x)]</code> .</p>
<p>In some cases, you can still rely on the order of execution. This applies to cases when <code>SELECT</code> comes from a subquery that uses <code>ORDER BY</code> .</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupArray(x)
groupArray(max_size)(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code> — input values.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>array of values. Type is Array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">select groupArray(number) from numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─groupArray(number)─────────────┐
│ [0, 1, 2, 3, 4, 5, 6, 7, 8, 9] │
└────────────────────────────────┘
</code></pre>
<pre><code class="sql">select groupArray(5)(number) from numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─groupArray(5)(number)─┐
│ [0, 1, 2, 3, 4]       │
└───────────────────────┘
</code></pre>
<h2 id="groupBitAnd"><a href="#groupBitAnd" class="headerlink" title="groupBitAnd"></a>groupBitAnd</h2><p>Applies bitwise <code>AND</code> for series of numbers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitAnd(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>UInt*</code> type.</li>
</ul>
<p><strong>Return value</strong></p>
<ul>
<li>Value of the <code>UInt*</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.groupBitAnd (num UInt8) ENGINE=CnchMergeTree() ORDER BY num;
INSERT INTO test.groupBitAnd VALUES (44),(28),(13),(85);
SELECT groupBitAnd(num) FROM test.groupBitAnd;
</code></pre>
<pre><code class="plain%20text">┌─groupBitAnd(num)─┐
│ 4                │
└──────────────────┘
</code></pre>
<p>Bit representation of 44,28,13 and 85 are 00101100,00011100,00001101 and 01010101. The bit and of the four numbers is 00000100 which is equal to 4.</p>
<h2 id="groupBitOr"><a href="#groupBitOr" class="headerlink" title="groupBitOr"></a>groupBitOr</h2><p>Applies bitwise <code>OR</code> for series of numbers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitOr(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>UInt*</code> type.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Value of the <code>UInt*</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionGroupBitOr (num UInt8) ENGINE=CnchMergeTree ORDER BY num;
INSERT INTO test.functionGroupBitOr VALUES (44),(28),(13),(85);
SELECT groupBitOr(num) FROM test.functionGroupBitOr;
</code></pre>
<pre><code class="plain%20text">┌─groupBitOr(num)─┐
│ 125             │
└─────────────────┘
</code></pre>
<p>Bit representation of 44,28,13 and 85 are 00101100,00011100,00001101 and 01010101. The bit or of the four numbers is 01111101 which is equal to 125.</p>
<h2 id="groupBitXor"><a href="#groupBitXor" class="headerlink" title="groupBitXor"></a>groupBitXor</h2><p>Applies bitwise <code>XOR</code> for series of numbers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitXor(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>UInt*</code> type.</li>
</ul>
<p><strong>Return value</strong></p>
<ul>
<li>Value of the <code>UInt*</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionGroupBitXor (num UInt8) ENGINE=CnchMergeTree ORDER BY num;
INSERT INTO test.functionGroupBitXor VALUES (44),(28),(13),(85);
SELECT groupBitXor(num) FROM test.functionGroupBitXor;
</code></pre>
<pre><code class="plain%20text">┌─groupBitXor(num)─┐
│ 104              │
└──────────────────┘
</code></pre>
<p>Bit representation of 44,28,13 and 85 are 00101100,00011100,00001101 and 01010101. The bit xor of the four numbers is 01101000 which is equal to 104.</p>
<h2 id="groupBitmap"><a href="#groupBitmap" class="headerlink" title="groupBitmap"></a>groupBitmap</h2><p>Bitmap or Aggregate calculations from a unsigned integer column, return cardinality of type UInt64, if add suffix -State, then return bitmap object.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitmap(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>UInt*</code> type.</li>
</ul>
<p><strong>Return value</strong></p>
<ul>
<li>Value of the <code>UInt64</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT groupBitmapState(number) FROM numbers(4);
</code></pre>
<pre><code class="plain%20text">┌─groupBitmap(number)─┐
│ 4                   │
└─────────────────────┘
</code></pre>
<h2 id="groupBitmapAnd"><a href="#groupBitmapAnd" class="headerlink" title="groupBitmapAnd"></a>groupBitmapAnd</h2><p>Calculations the AND of a bitmap column, return cardinality of type UInt64, if add suffix -State, then return bitmap object.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitmapAnd(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>AggregateFunction(groupBitmap, UInt*)</code> type.</li>
</ul>
<p><strong>Return value</strong></p>
<ul>
<li>Value of the <code>UInt64</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">DROP TABLE IF EXISTS bitmap_column_expr_test2;

CREATE TABLE bitmap_column_expr_test2(tag_id String,z AggregateFunction(groupBitmap, UInt32)) ENGINE = CnchMergeTree ORDER BY tag_id;

INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag1&#39;, bitmapBuild(cast([1,2,3,4,5,6,7,8,9,10] as Array(UInt32))));
INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag2&#39;, bitmapBuild(cast([6,7,8,9,10,11,12,13,14,15] as Array(UInt32))));
INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag3&#39;, bitmapBuild(cast([2,4,6,8,10,12] as Array(UInt32))));

SELECT groupBitmapAnd(z) FROM bitmap_column_expr_test2 WHERE like(tag_id, &#39;tag%&#39;);
┌─groupBitmapAnd(z)─┐
│               3   │
└───────────────────┘

SELECT arraySort(bitmapToArray(groupBitmapAndState(z))) FROM bitmap_column_expr_test2 WHERE like(tag_id, &#39;tag%&#39;);
┌─arraySort(bitmapToArray(groupBitmapAndState(z)))─┐
│ [6,8,10]                                         │
└──────────────────────────────────────────────────┘
</code></pre>
<h2 id="groupBitmapOr"><a href="#groupBitmapOr" class="headerlink" title="groupBitmapOr"></a>groupBitmapOr</h2><p>Calculations the OR of a bitmap column, return cardinality of type UInt64, if add suffix -State, then return bitmap object. This is equivalent to <code>groupBitmapMerge</code> .</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitmapOr(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>AggregateFunction(groupBitmap, UInt*)</code> type.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Value of the <code>UInt64</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">
DROP TABLE IF EXISTS bitmap_column_expr_test2;
CREATE TABLE bitmap_column_expr_test2(tag_id String,z AggregateFunction(groupBitmap, UInt32)) ENGINE = CnchMergeTree ORDER BY tag_id;

INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag1&#39;, bitmapBuild(cast([1,2,3,4,5,6,7,8,9,10] as Array(UInt32))));
INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag2&#39;, bitmapBuild(cast([6,7,8,9,10,11,12,13,14,15] as Array(UInt32))));
INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag3&#39;, bitmapBuild(cast([2,4,6,8,10,12] as Array(UInt32))));

SELECT groupBitmapOr(z) FROM bitmap_column_expr_test2 WHERE like(tag_id, &#39;tag%&#39;);

┌─groupBitmapOr(z)─┐
│             15   │
└──────────────────┘

SELECT arraySort(bitmapToArray(groupBitmapOrState(z))) FROM bitmap_column_expr_test2 WHERE like(tag_id, &#39;tag%&#39;);
┌─arraySort(bitmapToArray(groupBitmapOrState(z)))─┐
│ [1,2,3,4,5,6,7,8,9,10,11,12,13,14,15]           │
└─────────────────────────────────────────────────┘
</code></pre>
<h2 id="groupBitmapXor"><a href="#groupBitmapXor" class="headerlink" title="groupBitmapXor"></a>groupBitmapXor</h2><p>Calculations the XOR of a bitmap column, return cardinality of type UInt64, if add suffix -State, then return bitmap object.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupBitmapOr(expr)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>expr</code> – An expression that results in <code>AggregateFunction(groupBitmap, UInt*)</code> type.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Value of the <code>UInt64</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">
DROP TABLE IF EXISTS bitmap_column_expr_test2;
CREATE TABLE bitmap_column_expr_test2(tag_id String, z AggregateFunction(groupBitmap, UInt32)) ENGINE = CnchMergeTree ORDER BY tag_id;


INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag1&#39;, bitmapBuild(cast([1,2,3,4,5,6,7,8,9,10] as Array(UInt32))));
INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag2&#39;, bitmapBuild(cast([6,7,8,9,10,11,12,13,14,15] as Array(UInt32))));
INSERT INTO bitmap_column_expr_test2 VALUES (&#39;tag3&#39;, bitmapBuild(cast([2,4,6,8,10,12] as Array(UInt32))));

SELECT groupBitmapXor(z) FROM bitmap_column_expr_test2 WHERE like(tag_id, &#39;tag%&#39;);
┌─groupBitmapXor(z)─┐
│              10   │
└───────────────────┘

SELECT arraySort(bitmapToArray(groupBitmapXorState(z))) FROM bitmap_column_expr_test2 WHERE like(tag_id, &#39;tag%&#39;);

┌─arraySort(bitmapToArray(groupBitmapXorState(z)))─┐
│ [1,3,5,6,8,10,11,13,14,15]                       │
└──────────────────────────────────────────────────┘
</code></pre>
<h2 id="groupUniqArray"><a href="#groupUniqArray" class="headerlink" title="groupUniqArray"></a>groupUniqArray</h2><p>Creates an array from different argument values. Memory consumption is the same as for the uniqExact function.</p>
<p>The second version (with the <code>max_size</code> parameter) limits the size of the resulting array to <code>max_size</code> elements.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">groupUniqArray(x)
groupUniqArray(max_size)(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>x</code> — input values.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>array of values. Type is Array.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">select groupUniqArray(number) from numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─groupUniqArray(number)─────────┐
│ [0, 8, 3, 9, 7, 2, 1, 6, 4, 5] │
└────────────────────────────────┘
</code></pre>
<!-- TODO: Below Function Does Not Work In CNCH, Check with ChenXing -->
<pre><code class="sql">select groupUniqArray(5)(number) from numbers(10); 
</code></pre>
<pre><code class="plain%20text">┌─groupArray(5)(number)─┐
│ [0, 1, 2, 3, 4]       │
└───────────────────────┘
</code></pre>
<h2 id="histogram"><a href="#histogram" class="headerlink" title="histogram"></a>histogram</h2><p>Calculates an adaptive histogram. It does not guarantee precise results.</p>
<p>The functions uses <a href="http://jmlr.org/papers/volume11/ben-haim10a/ben-haim10a.pdf">A Streaming Parallel Decision Tree Algorithm</a> . The borders of histogram bins are adjusted as new data enters a function. In common case, the widths of bins are not equal.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">histogram(number_of_bins)(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>number_of_bins</code> — Upper limit for the number of bins in the histogram. The function automatically calculates the number of bins. It tries to reach the specified number of bins, but if it fails, it uses fewer bins.</li>
<li><code>values</code> — Expression resulting in input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>Array of Tuples of the following format:</li>
</ul>
<pre><code>[(lower_1, upper_1, height_1), ... (lower_N, upper_N, height_N)]

- `lower` — Lower bound of the bin.
- `upper` — Upper bound of the bin.
- `height` — Calculated height of the bin.
</code></pre>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT histogram(5)(number + 1) FROM numbers(20);
</code></pre>
<pre><code class="plain%20text">┌─histogram(5)(plus(number, 1))───────────────────────────────────────────┐
│ [(1,4.5,4),(4.5,8.5,4),(8.5,12.75,4.125),(12.75,17,4.625),(17,20,3.25)] │
└─────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>You can visualize a histogram with the bar function, for example:</p>
<pre><code class="sql">
WITH histogram(5)(rand() % 100) AS hist
SELECT
    arrayJoin(hist).3 AS height,
    bar(height, 0, 6, 5) AS bar
FROM numbers(20);
</code></pre>
<pre><code class="plain%20text">
┌─height─┬─bar───┐

│  2.125 │ █▋    │

│   3.25 │ ██▌   │

│  5.625 │ ████▏ │

│  5.625 │ ████▏ │

│  3.375 │ ██▌   │

└────────┴───────┘
</code></pre>
<p>In this case, you should remember that you do not know the histogram bin borders.</p>
<h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><p>Aggregate function that calculates the maximum across a group of values.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">max(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>values</code> — input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>maximum value. Type is same as values</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT max(number) FROM numbers(20);
</code></pre>
<pre><code class="plain%20text">┌─max(number)─┐
│ 19          │
└─────────────┘
</code></pre>
<p>If you need non-aggregate function to choose a maximum of two values, see <code>greatest</code> :</p>
<pre><code class="sql">SELECT greatest(a, b) FROM table;
</code></pre>
<h2 id="median"><a href="#median" class="headerlink" title="median"></a>median</h2><p>The <code>median*</code> functions are the aliases for the corresponding <code>quantile*</code> functions. They calculate median of a numeric data sample.</p>
<p>Functions:</p>
<ul>
<li><code>median</code> — Alias for quantile. </li>
<li><code>medianDeterministic</code> — Alias for quantileDeterministic. </li>
<li><code>medianExact</code> — Alias for quantileExact. </li>
<li><code>medianExactWeighted</code> — Alias for quantileExactWeighted. </li>
<li><code>medianTiming</code> — Alias for quantileTiming.</li>
<li><code>medianTimingWeighted</code> — Alias for quantileTimingWeighted. </li>
<li><code>medianTDigest</code> — Alias for quantileTDigest. </li>
<li><code>medianTDigestWeighted</code> — Alias for quantileTDigestWeighted. </li>
<li><code>medianBFloat16</code> — Alias for quantileBFloat16.</li>
</ul>
<h2 id="medianDeterministic"><a href="#medianDeterministic" class="headerlink" title="medianDeterministic"></a>medianDeterministic</h2><p>Alias for quantileDeterministic.</p>
<h2 id="medianExact"><a href="#medianExact" class="headerlink" title="medianExact"></a>medianExact</h2><p>Alias for quantileExact.</p>
<h2 id="medianExactWeighted"><a href="#medianExactWeighted" class="headerlink" title="medianExactWeighted"></a>medianExactWeighted</h2><p>Alias for quantileExactWeighted.</p>
<h2 id="medianTDigest"><a href="#medianTDigest" class="headerlink" title="medianTDigest"></a>medianTDigest</h2><p>Alias for quantileTDigest.</p>
<h2 id="medianTDigestWeighted"><a href="#medianTDigestWeighted" class="headerlink" title="medianTDigestWeighted"></a>medianTDigestWeighted</h2><p>Alias for quantileTDigestWeighted.</p>
<h2 id="medianTiming"><a href="#medianTiming" class="headerlink" title="medianTiming"></a>medianTiming</h2><p>Alias for quantileTiming.</p>
<h2 id="medianTimingWeighted"><a href="#medianTimingWeighted" class="headerlink" title="medianTimingWeighted"></a>medianTimingWeighted</h2><p>Alias for quantileTimingWeighted.</p>
<h2 id="quantile"><a href="#quantile" class="headerlink" title="quantile"></a>quantile</h2><p>Computes an approximate <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence.</p>
<p>This function applies <a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a> with a reservoir size up to 8192 and a random number generator for sampling. The result is non-deterministic. To get an exact quantile, use the quantileExact function.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantile(level)(expr)
</code></pre>
<p>Alias: <code>median</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over the column values resulting in numeric, Date, or DateTime.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Approximate quantile of the specified level.<br>Type:</li>
<li>Float64 for numeric data type input. </li>
<li>Date if input values have the <code>Date</code> type.</li>
<li>DateTime if input values have the <code>DateTime</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT quantile(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─quantile(number)─┐
│ 4.5e+00          │
└──────────────────┘
</code></pre>
<h2 id="quantileDeterministic"><a href="#quantileDeterministic" class="headerlink" title="quantileDeterministic"></a>quantileDeterministic</h2><p>Computes an approximate <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence.</p>
<p>This function applies <a href="https://en.wikipedia.org/wiki/Reservoir_sampling">reservoir sampling</a> with a reservoir size up to 8192 and deterministic algorithm of sampling. The result is deterministic. To get an exact quantile, use the quantileExact function.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileDeterministic(level)(expr, determinator)
</code></pre>
<p>Alias: <code>medianDeterministic</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over the column values resulting in numeric data types, Date or DateTime. </li>
<li><code>determinator</code> — Number whose hash is used instead of a random number generator in the reservoir sampling algorithm to make the result of sampling deterministic. As a determinator you can use any deterministic positive number, for example, a user id or an event id. If the same determinator value occures too often, the function works incorrectly.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Approximate quantile of the specified level.<br>Type:</li>
<li>Float64 for numeric data type input. </li>
<li>Date if input values have the <code>Date</code> type.</li>
<li>DateTime if input values have the <code>DateTime</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT quantileDeterministic(number, 1) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─quantileDeterministic(number, 1)─┐
│ 4.5e+00                          │
└──────────────────────────────────┘
</code></pre>
<h2 id="quantileExact"><a href="#quantileExact" class="headerlink" title="quantileExact"></a>quantileExact</h2><p>Exactly computes the <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence.</p>
<p>To get exact value, all the passed values are combined into an array, which is then partially sorted. Therefore, the function consumes <code>O(n)</code> memory, where <code>n</code> is a number of values that were passed. However, for a small number of values, the function is very effective.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileExact(level)(expr)
</code></pre>
<p>Alias: <code>medianExact</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over the column values resulting in numeric data types, Date or DateTime.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Quantile of the specified level.<br>Type:</li>
<li>Float64 for numeric data type input. </li>
<li>Date if input values have the <code>Date</code> type. </li>
<li>DateTime if input values have the <code>DateTime</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT quantileExact(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─quantileExact(number)─┐
│                     5 │
└───────────────────────┘
</code></pre>
<h2 id="quantileExactWeighted"><a href="#quantileExactWeighted" class="headerlink" title="quantileExactWeighted"></a>quantileExactWeighted</h2><p>Exactly computes the <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence, taking into account the weight of each element.</p>
<p>To get exact value, all the passed values are combined into an array, which is then partially sorted. Each value is counted with its weight, as if it is present <code>weight</code> times. A hash table is used in the algorithm. Because of this, if the passed values are frequently repeated, the function consumes less RAM than quantileExact. You can use this function instead of <code>quantileExact</code> and specify the weight 1.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileExactWeighted(level)(expr, weight)
</code></pre>
<p>Alias: <code>medianExactWeighted</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over the column values resulting in numeric, Date or DateTime. </li>
<li><code>weight</code> — Column with weights of sequence members. Weight is a number of value occurrences.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Quantile of the specified level.<br>Type:</li>
<li>Float64 for numeric data type input. </li>
<li>Date if input values have the <code>Date</code> type. </li>
<li>DateTime if input values have the <code>DateTime</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionQuantileExactWeighted (n UInt8, val UInt8) ENGINE=CnchMergeTree ORDER BY n;
INSERT INTO test.functionQuantileExactWeighted VALUES (0,3),(1,2),(2,1),(5,4);
SELECT quantileExactWeighted(n, val) FROM test.functionQuantileExactWeighted;
</code></pre>
<pre><code class="plain%20text">┌─quantileExactWeighted(n, val)─┐
│                             1 │
└───────────────────────────────┘
</code></pre>
<h2 id="quantileTDigest"><a href="#quantileTDigest" class="headerlink" title="quantileTDigest"></a>quantileTDigest</h2><p>Computes an approximate <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence using the <a href="https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf">t-digest</a> algorithm.</p>
<p>Memory consumption is <code>log(n)</code> , where <code>n</code> is a number of values. The result depends on the order of running the query, and is nondeterministic.</p>
<p>The performance of the function is lower than performance of quantile or quantileTiming. In terms of the ratio of State size to precision, this function is much better than <code>quantile</code> .</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileTDigest(level)(expr)
</code></pre>
<p>Alias: <code>medianTDigest</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over the column values resulting in numeric data types, Date or DateTime.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Approximate quantile of the specified level.<br>Type:</li>
<li>Float64 for numeric data type input. </li>
<li>Date if input values have the <code>Date</code> type. </li>
<li>DateTime if input values have the <code>DateTime</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT quantileTDigest(number) FROM numbers(10)
</code></pre>
<pre><code class="plain%20text">┌─quantileTDigest(number)─┐
│ 4.5e+00                 │
└─────────────────────────┘
</code></pre>
<h2 id="quantileTDigestWeighted"><a href="#quantileTDigestWeighted" class="headerlink" title="quantileTDigestWeighted"></a>quantileTDigestWeighted</h2><p>Computes an approximate <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence using the <a href="https://github.com/tdunning/t-digest/blob/master/docs/t-digest-paper/histo.pdf">t-digest</a> algorithm. The function takes into account the weight of each sequence member. The maximum error is 1%. Memory consumption is <code>log(n)</code> , where <code>n</code> is a number of values.</p>
<p>The performance of the function is lower than the performance of quantile or quantileTiming. In terms of the ratio of State size to precision, this function is much better than <code>quantile</code>.</p>
<p>The result depends on the order of running the query and is nondeterministic.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p>[block:callout]<br>{<br>  “type”: “info”,<br>  “title”: “Note”,<br>  “body”: “Using <code>quantileTDigestWeighted</code> <a href="https://github.com/tdunning/t-digest/issues/167#issuecomment-828650275">is not recommended for tiny data sets</a> and can lead to significat error. In this case, consider possibility of using <code>quantileTDigest</code> instead.”<br>}<br>[&#x2F;block]<br><strong>Syntax</strong></p>
<pre><code class="sql">quantileTDigestWeighted(level)(expr, weight)
</code></pre>
<p>Alias: <code>medianTDigestWeighted</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over the column values resulting in numeric data types, Date or DateTime. </li>
<li><code>weight</code> — Column with weights of sequence elements. Weight is a number of value occurrences.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Approximate quantile of the specified level.<br>Type:</li>
<li>Float64 for numeric data type input. </li>
<li>Date if input values have the <code>Date</code> type. </li>
<li>DateTime if input values have the <code>DateTime</code> type.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT quantileTDigestWeighted(number, 1) FROM numbers(10)
</code></pre>
<pre><code class="plain%20text">┌─quantileTDigestWeighted(number, 1)─┐
│ 4.5e+00                            │
└────────────────────────────────────┘
</code></pre>
<h2 id="quantileTiming"><a href="#quantileTiming" class="headerlink" title="quantileTiming"></a>quantileTiming</h2><p>With the determined precision computes the <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence.</p>
<p>The result is deterministic (it does not depend on the query processing order). The function is optimized for working with sequences which describe distributions like loading web pages times or backend response times.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileTiming(level)(expr)
</code></pre>
<p>Alias: <code>medianTiming</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over a column values returning a Float* -type number. <ul>
<li>If negative values are passed to the function, the behavior is undefined. </li>
<li>If the value is greater than 30,000 (a page loading time of more than 30 seconds), it is assumed to be 30,000.</li>
</ul>
</li>
</ul>
<p><strong>Accuracy</strong><br>The calculation is accurate if:</p>
<ul>
<li>Total number of values does not exceed 5670. </li>
<li>Total number of values exceeds 5670, but the page loading time is less than 1024ms.</li>
</ul>
<p>Otherwise, the result of the calculation is rounded to the nearest multiple of 16 ms.</p>
<p>!!! note “Note”<br>For calculating page loading time quantiles, this function is more effective and accurate than quantile.</p>
<p><strong>Returned value</strong></p>
<ul>
<li>Quantile of the specified level.<br>Type: <code>Float32</code> .</li>
</ul>
<p>!!! note “Note”<br>If no values are passed to the function (when using <code>quantileTimingIf</code> ), NaN is returned. The purpose of this is to differentiate these cases from cases that result in zero. See ORDER BY clause for notes on sorting <code>NaN</code> values.</p>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionQuantileTiming (response_time UInt32) ENGINE=CnchMergeTree ORDER BY response_time;
INSERT INTO test.functionQuantileTiming VALUES (72),(112),(126),(145),(104),(242),(313),(168),(108);
SELECT quantileTiming(response_time) FROM test.functionQuantileTiming;
</code></pre>
<pre><code class="plain%20text">┌─quantileTiming(response_time)─┐
│ 1.26e+02                      │
└───────────────────────────────┘
</code></pre>
<h2 id="quantileTimingWeighted"><a href="#quantileTimingWeighted" class="headerlink" title="quantileTimingWeighted"></a>quantileTimingWeighted</h2><p>With the determined precision computes the <a href="https://en.wikipedia.org/wiki/Quantile">quantile</a> of a numeric data sequence according to the weight of each sequence member.</p>
<p>The result is deterministic (it does not depend on the query processing order). The function is optimized for working with sequences which describe distributions like loading web pages times or backend response times.</p>
<p>When using multiple <code>quantile*</code> functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the quantiles function.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileTimingWeighted(level)(expr, weight)
</code></pre>
<p>Alias: <code>medianTimingWeighted</code> .</p>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level</code> — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code> . Default value: 0.5. At <code>level=0.5</code> the function calculates <a href="https://en.wikipedia.org/wiki/Median">median</a> . </li>
<li><code>expr</code> — Expression over a column values returning a Float* -type number. </li>
<li>If negative values are passed to the function, the behavior is undefined.</li>
<li>If the value is greater than 30,000 (a page loading time of more than 30 seconds), it is assumed to be 30,000.</li>
<li><code>weight</code> — Column with weights of sequence elements. Weight is a number of value occurrences.</li>
</ul>
<p><strong>Accuracy</strong><br>The calculation is accurate if:</p>
<ul>
<li>Total number of values does not exceed 5670. </li>
<li>Total number of values exceeds 5670, but the page loading time is less than 1024ms.</li>
</ul>
<p>Otherwise, the result of the calculation is rounded to the nearest multiple of 16 ms.</p>
<p>!!! note “Note”<br>For calculating page loading time quantiles, this function is more effective and accurate than quantile.</p>
<p><strong>Returned value</strong></p>
<ul>
<li>Quantile of the specified level.<br>Type: <code>Float32</code> .</li>
</ul>
<p>!!! note “Note”<br>If no values are passed to the function (when using <code>quantileTimingIf</code> ), NaN is returned. The purpose of this is to differentiate these cases from cases that result in zero. See ORDER BY clause for notes on sorting <code>NaN</code> values.</p>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionQuantileTimingWeighted (response_time UInt32, weight UInt32) ENGINE=CnchMergeTree ORDER BY response_time;
INSERT INTO test.functionQuantileTimingWeighted VALUES (68,1),(104,2),(112,3),(126,2),(138,1),(162,1);
SELECT quantileTimingWeighted(response_time, weight) FROM test.functionQuantileTimingWeighted;
</code></pre>
<pre><code class="plain%20text">┌─quantileTimingWeighted(response_time, weight)─┐
│ 1.12e+02                                      │
└───────────────────────────────────────────────┘
</code></pre>
<h2 id="quantiles"><a href="#quantiles" class="headerlink" title="quantiles"></a>quantiles</h2><p>All the quantile functions also have corresponding quantiles functions: <code>quantiles</code> , <code>quantilesDeterministic</code> , <code>quantilesTiming</code> , <code>quantilesTimingWeighted</code> , <code>quantilesExact</code> , <code>quantilesExactWeighted</code> , <code>quantilesTDigest</code> , <code>quantilesBFloat16</code> . These functions calculate all the quantiles of the listed levels in one pass, and return an array of the resulting values.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantiles(level1, level2, …)(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level1,level2...</code> — Levels of quantiles. Each level is a constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code>.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>A list of quantiles.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT quantiles(0.5,0.4)(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─quantiles(0.5, 0.4)(number)─┐
│ [4.5e+00, 3.6e+00]          │
└─────────────────────────────┘
</code></pre>
<p>quantiles(0.5,0.4)(number) equivalent to quantile(0.5)(number) and quantile(0.4)(number).</p>
<h2 id="quantilesTimingWeighted"><a href="#quantilesTimingWeighted" class="headerlink" title="quantilesTimingWeighted"></a>quantilesTimingWeighted</h2><p>Same as <code>quantileTimingWeighted</code> , but accept multiple parameters with quantile levels and return an Array filled with many values of that quantiles.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">quantileTimingWeighted(level1, level2, …)(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>level1,level2...</code> — Levels of quantiles. Each level is a constant floating-point number from 0 to 1. We recommend using a <code>level</code> value in the range of <code>[0.01, 0.99]</code>.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>A list of quantiles.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionQuantilesTimingWeighted (response_time UInt32, weight UInt32) ENGINE=CnchMergeTree ORDER BY response_time;
INSERT INTO test.functionQuantilesTimingWeighted VALUES (68,1),(104,2),(112,3),(126,2),(138,1),(162,1);
SELECT quantilesTimingWeighted(0.5, 0.99)(response_time, weight) FROM test.functionQuantilesTimingWeighted;
</code></pre>
<pre><code class="plain%20text">┌─quantilesTimingWeighted(0.5, 0.99)(response_time, weight)─┐
│ [1.12e+02, 1.62e+02]                                      │
└───────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="sequenceCount"><a href="#sequenceCount" class="headerlink" title="sequenceCount"></a>sequenceCount</h2><p>sequenceCount(pattern)(time, cond1, cond2, …)</p>
<p>Counts the number of event chains that matched the pattern. The function searches event chains that do not overlap. It starts to search for the next chain after the current chain is matched.</p>
<p>!!! warning “Warning”<br>Events that occur at the same second may lay in the sequence in an undefined order affecting the result.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sequenceCount(pattern)(timestamp, cond1, cond2, ...)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>pattern</code> — Pattern string. See Pattern syntax. </li>
<li><code>timestamp</code> — Column considered to contain time data. Typical data types are <code>Date</code> and <code>DateTime</code> . You can also use any of the supported UInt data types. </li>
<li><code>cond1</code> , <code>cond2</code> — Conditions that describe the chain of events. Data type: <code>UInt8</code> . You can pass up to 32 condition arguments. The function takes only the events described in these conditions into account. If the sequence contains data that isn’t described in a condition, the function skips them.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>Number of non-overlapping event chains that are matched.<br>Type: <code>UInt64</code> .</li>
</ul>
<p><strong>Example</strong><br>Count how many times the number 2 occurs after the number 1 with any amount of other numbers between them:</p>
<pre><code class="sql">CREATE TABLE test.functionSequenceCount (time DateTime, number UInt8) ENGINE=CnchMergeTree ORDER BY time;
INSERT INTO test.functionSequenceCount VALUES (1,1),(2,3),(3,2),(4,1),(5,3),(6,2);
SELECT sequenceCount(&#39;(?1).*(?2)&#39;)(time, number = 1, number = 2) FROM test.functionSequenceCount;
</code></pre>
<pre><code class="plain%20text">┌─sequenceCount(&#39;(?1).*(?2)&#39;)(time, equals(number, 1), equals(number, 2))─┐
│                                                                       2 │
└─────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="sequenceMatch"><a href="#sequenceMatch" class="headerlink" title="sequenceMatch"></a>sequenceMatch</h2><p>sequenceMatch(pattern)(timestamp, cond1, cond2, …)</p>
<p>Checks whether the sequence contains an event chain that matches the pattern.</p>
<p>!!! warning “Warning”<br>Events that occur at the same second may lay in the sequence in an undefined order affecting the result.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sequenceMatch(pattern)(timestamp, cond1, cond2, ...)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>pattern</code> — Pattern string. See Pattern syntax. </li>
<li><code>timestamp</code> — Column considered to contain time data. Typical data types are <code>Date</code> and <code>DateTime</code> . You can also use any of the supported UInt data types. </li>
<li><code>cond1</code> , <code>cond2</code> — Conditions that describe the chain of events. Data type: <code>UInt8</code> . You can pass up to 32 condition arguments. The function takes only the events described in these conditions into account. If the sequence contains data that isn’t described in a condition, the function skips them.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>1, if the pattern is matched. </li>
<li>0, if the pattern isn’t matched.<br>Type: <code>UInt8</code> .</li>
</ul>
<p><strong>Pattern syntax</strong></p>
<ul>
<li><code>(?N)</code> — Matches the condition argument at position <code>N</code> . Conditions are numbered in the <code>[1, 32]</code> range. For example, <code>(?1)</code> matches the argument passed to the <code>cond1</code> parameter. </li>
<li><code>.*</code> — Matches any number of events. You do not need conditional arguments to match this element of the pattern. </li>
<li><code>(?t operator value)</code> — Sets the time in seconds that should separate two events. For example, pattern <code>(?1)(?t&gt;1800)(?2)</code> matches events that occur more than 1800 seconds from each other. An arbitrary number of any events can lay between these events. You can use the <code>&gt;=</code> , <code>&gt;</code> , <code>&lt;</code> , <code>&lt;=</code> , <code>==</code> operators.</li>
</ul>
<p><strong>Examples</strong><br>Consider data in the <code>t</code> table:</p>
<pre><code class="plain%20text">
┌─time─┬─number─┐

│    1 │      1 │

│    2 │      3 │

│    3 │      2 │

└──────┴────────┘
</code></pre>
<p>Perform the query:</p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionSequenceMatch (time DateTime, number UInt8) ENGINE=CnchMergeTree ORDER BY time;
INSERT INTO test.functionSequenceMatch VALUES (1,1),(2,3),(3,2);
SELECT sequenceMatch(&#39;(?1)(?2)&#39;)(time, number = 1, number = 2) FROM test.functionSequenceMatch;
</code></pre>
<pre><code class="plain%20text">┌─sequenceMatch(&#39;(?1)(?2)&#39;)(time, equals(number, 1), equals(number, 2))─┐
│                                                                     1 │
└───────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>The function found the event chain where number 2 follows number 1. It skipped number 3 between them, because the number is not described as an event. If we want to take this number into account when searching for the event chain given in the example, we should make a condition for it.</p>
<pre><code class="sql">SELECT sequenceMatch(&#39;(?1)(?2)&#39;)(time, number = 1, number = 2, number = 3) FROM test.functionSequenceMatch;
</code></pre>
<pre><code class="plain%20text">┌─sequenceMatch(&#39;(?1)(?2)&#39;)(time, equals(number, 1), equals(number, 2), equals(number, 3))─┐
│                                                                                        0 │
└──────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<p>In this case, the function couldn’t find the event chain matching the pattern, because the event for number 3 occured between 1 and 2. If in the same case we checked the condition for number 4, the sequence would match the pattern.</p>
<pre><code class="sql">SELECT sequenceMatch(&#39;(?1)(?2)&#39;)(time, number = 1, number = 2, number = 4) FROM test.functionSequenceMatch;
</code></pre>
<pre><code class="plain%20text">┌─sequenceMatch(&#39;(?1)(?2)&#39;)(time, equals(number, 1), equals(number, 2), equals(number, 4))─┐
│                                                                                        1 │
└──────────────────────────────────────────────────────────────────────────────────────────┘
</code></pre>
<h2 id="stddevPop"><a href="#stddevPop" class="headerlink" title="stddevPop"></a>stddevPop</h2><p>The result is equal to the square root of varPop.</p>
<p>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>stddevPopStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">stddevPop(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>values</code> — input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>stddevPop of values. Returns Float64.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT stddevPop(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─stddevPop(number)──────┐
│ 2.8722813232690143e+00 │
└────────────────────────┘
</code></pre>
<h2 id="stddevSamp"><a href="#stddevSamp" class="headerlink" title="stddevSamp"></a>stddevSamp</h2><p>The result is equal to the square root of varSamp.</p>
<p>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>stddevSampStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">stddevSamp(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>values</code> — input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>stddevSamp of values. Returns Float64.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT stddevSamp(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─stddevSamp(number)─────┐
│ 3.0276503540974917e+00 │
└────────────────────────┘
</code></pre>
<h2 id="STDDEV-POP"><a href="#STDDEV-POP" class="headerlink" title="STDDEV_POP"></a>STDDEV_POP</h2><p>Alias to stddevPop.</p>
<h2 id="STDDEV-SAMP"><a href="#STDDEV-SAMP" class="headerlink" title="STDDEV_SAMP"></a>STDDEV_SAMP</h2><p>Alias to stddevSamp.</p>
<h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><p>Calculates the sum. Only works for numbers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sum(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>values</code> — input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>sum of values. Type is same as values</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT sum(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─sum(number)─┐
│ 45          │
└─────────────┘
</code></pre>
<p>sum from 0 to 9.</p>
<h2 id="sumKahan"><a href="#sumKahan" class="headerlink" title="sumKahan"></a>sumKahan</h2><p>Calculates the sum of the numbers with <a href="https://en.wikipedia.org/wiki/Kahan_summation_algorithm">Kahan compensated summation algorithm</a><br>Slower than sum function.</p>
<p>The compensation works only for Float types.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sumKahan(x)
</code></pre>
<p><strong>Arguments</strong> </p>
<ul>
<li><code>x</code> — Input value, must be Integer, Float, or Decimal.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>the sum of numbers, with type Integer, Float, or Decimal depends on type of input arguments</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT sum(0.1), sumKahan(0.1) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─sum(0.1)──────────────┬─sumKahan(0.1)─┐
│ 9.999999999999999e-01 │ 1e+00         │
└───────────────────────┴───────────────┘
</code></pre>
<h2 id="sumMap"><a href="#sumMap" class="headerlink" title="sumMap"></a>sumMap</h2><p>Totals the <code>value</code> array according to the keys specified in the <code>key</code> array.<br>The number of elements in <code>key</code> and <code>value</code> must be the same for each row that is totaled.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sumMap(key, value)
</code></pre>
<p><strong>Arguments</strong> </p>
<ul>
<li><code>key</code> — Input keys. Type Array</li>
<li><code>value</code> — Input values. Type Array</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Returns a tuple of two arrays: keys in sorted order, and values summed for the corresponding keys.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE test.functionSumMap(
    date Date,
    timeslot DateTime,
    status UInt16,
    requests UInt64
) ENGINE = CnchMergeTree ORDER BY date;

INSERT INTO test.functionSumMap VALUES
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:00:00&#39;, 1,2),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:00:00&#39;, 1,5),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:00:00&#39;, 3,4),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:01:00&#39;, 5,6),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:01:00&#39;, 7,8);

SELECT timeslot, sumMap([status], [requests]) FROM test.functionSumMap GROUP BY timeslot;
</code></pre>
<pre><code class="plain%20text">┌─timeslot────────────┬─sumMap(array(status), array(requests))─┐
│ 2000-01-01 00:00:00 │ ([1, 3], [7, 4])                       │
│ 2000-01-01 00:01:00 │ ([5, 7], [6, 8])                       │
└─────────────────────┴────────────────────────────────────────┘
</code></pre>
<h2 id="sumMapFiltered"><a href="#sumMapFiltered" class="headerlink" title="sumMapFiltered"></a>sumMapFiltered</h2><p>Same behavior as sumMap except that an array of keys is passed as a parameter. This can be especially useful when working with a high cardinality of keys.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sumMapFiltered(keys_to_keep)(keys, values)
</code></pre>
<p><strong>Arguments</strong> </p>
<ul>
<li><code>keys_to_keep</code> - Input keys_to_keep. Type Array</li>
<li><code>key</code> — Input keys. Type Array</li>
<li><code>value</code> — Input values. Type Array</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Returns a tuple of two arrays: keys in sorted order, and values summed for the corresponding keys.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE test.functionSumMapFiltered(
    date Date,
    timeslot DateTime,
    status UInt16,
    requests UInt64
) ENGINE = CnchMergeTree ORDER BY date;

INSERT INTO test.functionSumMapFiltered VALUES
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:00:00&#39;, 1,2),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:00:00&#39;, 1,5),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:00:00&#39;, 3,4),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:01:00&#39;, 5,6),
    (&#39;2000-01-01&#39;, &#39;2000-01-01 00:01:00&#39;, 7,8);

SELECT timeslot, sumMapFiltered([1])([status], [requests]) FROM test.functionSumMapFiltered GROUP BY timeslot;
</code></pre>
<pre><code class="plain%20text">┌─timeslot────────────┬─sumMapFiltered([1])(array(status), array(requests))─┐
│ 2000-01-01 00:00:00 │ ([1], [7])                                          │
│ 2000-01-01 00:01:00 │ ([], [])                                            │
└─────────────────────┴─────────────────────────────────────────────────────┘
</code></pre>
<h2 id="sumWithOverflow"><a href="#sumWithOverflow" class="headerlink" title="sumWithOverflow"></a>sumWithOverflow</h2><p>Computes the sum of the numbers, using the same data type for the result as for the input parameters. If the sum exceeds the maximum value for this data type, it is calculated with overflow.</p>
<p>Only works for numbers.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">sumWithOverflow(values)
</code></pre>
<p><strong>Arguments</strong> </p>
<ul>
<li><code>values</code> - Input Values.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>Sum of the numbers.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">CREATE TABLE IF NOT EXISTS test.functionSumWithOverflow (x UInt8) ENGINE=CnchMergeTree ORDER BY x;
INSERT INTO test.functionSumWithOverflow values (254),(254);
SELECT sum(x), sumWithOverflow(x) FROM test.functionSumWithOverflow;
</code></pre>
<pre><code class="plain%20text">┌─sum(x)─┬─sumWithOverflow(x)─┐
│ 508    │ 252                │
└────────┴────────────────────┘
</code></pre>
<h2 id="topK"><a href="#topK" class="headerlink" title="topK"></a>topK</h2><p>Returns an array of the approximately most frequent values in the specified column. The resulting array is sorted in descending order of approximate frequency of values (not by the values themselves).</p>
<p>Implements the <a href="http://www.l2f.inesc-id.pt/~fmmb/wiki/uploads/Work/misnis.ref0a.pdf">Filtered Space-Saving</a> algorithm for analyzing TopK, based on the reduce-and-combine algorithm from <a href="https://arxiv.org/pdf/1401.0702.pdf">Parallel Space Saving</a> .</p>
<p>This function does not provide a guaranteed result. In certain situations, errors might occur and it might return frequent values that aren’t the most frequent values.</p>
<p>We recommend using the <code>N &lt; 10</code> value; performance is reduced with large <code>N</code> values. Maximum value of <code>N = 65536</code> .</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">topK(N)(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N</code> – The number of elements to return. If the parameter is omitted, default value 10 is used.</li>
<li><code>x</code> – The values to calculate frequency.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT topK(3)(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─topK(3)(number)─┐
│ [0, 1, 2]       │
└─────────────────┘
</code></pre>
<h2 id="topKWeighted"><a href="#topKWeighted" class="headerlink" title="topKWeighted"></a>topKWeighted</h2><p>Returns an array of the approximately most frequent values in the specified column. The resulting array is sorted in descending order of approximate frequency of values (not by the values themselves). Additionally, the weight of the value is taken into account.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">topKWeighted(N)(x, weight)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N</code> — The number of elements to return. </li>
<li><code>x</code> — The value. </li>
<li><code>weight</code> — The weight. Every value is accounted <code>weight</code> times for frequency calculation. UInt64.</li>
</ul>
<p><strong>Returned value</strong><br>Returns an array of the values with maximum approximate sum of weights.</p>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT topKWeighted(10)(number, number) FROM numbers(1000)
</code></pre>
<!-- TODO: Verified WITH CNCH. Result Incorrect. -->

<pre><code class="plain%20text">┌─topKWeighted(10)(number, number)──────────┐
│ [999,998,997,996,995,994,993,992,991,990] │
└───────────────────────────────────────────┘
</code></pre>
<h2 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h2><p>Calculates the approximate number of different values of the argument.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">uniq(x[, ...])
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li>The function takes a variable number of parameters. Parameters can be <code>Tuple</code> , <code>Array</code> , <code>Date</code> , <code>DateTime</code> , <code>String</code> , or numeric types.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>A UInt64 -type number.</li>
</ul>
<p><strong>Implementation details</strong><br>Function:</p>
<ul>
<li>Calculates a hash for all parameters in the aggregate, then uses it in calculations. </li>
<li>Uses an adaptive sampling algorithm. For the calculation state, the function uses a sample of element hash values up to 65536.</li>
</ul>
<p>This algorithm is very accurate and very efficient on the CPU. When the query contains several of these functions, using <code>uniq</code> is almost as fast as using other aggregate functions.This algorithm is very accurate and very efficient on the CPU. When the query contains several of these functions, using <code>uniq</code> is almost as fast as using other aggregate functions.</p>
<ul>
<li>Provides the result deterministically (it does not depend on the query processing order).</li>
</ul>
<p>We recommend using this function in almost all scenarios.</p>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT uniq(number) FROM numbers(1000);
</code></pre>
<h2 id="uniqCombined"><a href="#uniqCombined" class="headerlink" title="uniqCombined"></a>uniqCombined</h2><p>Calculates the approximate number of different argument values.<br>The <code>uniqCombined</code> function is a good choice for calculating the number of different values.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">uniqCombined(HLL_precision)(x[, ...])
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li>The function takes a variable number of parameters. Parameters can be <code>Tuple</code> , <code>Array</code> , <code>Date</code> , <code>DateTime</code> , <code>String</code> , or numeric types.</li>
<li><code>HLL_precision</code> is the base-2 logarithm of the number of cells in <a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a> . Optional, you can use the function as <code>uniqCombined(x[, ...])</code> . The default value for <code>HLL_precision</code> is 17, which is effectively 96 KiB of space (2^17 cells, 6 bits each).</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>A number UInt64 -type number.</li>
</ul>
<p><strong>Implementation details</strong><br>Function:</p>
<ul>
<li>Calculates a hash (64-bit hash for <code>String</code> and 32-bit otherwise) for all parameters in the aggregate, then uses it in calculations. </li>
<li>Uses a combination of three algorithms: array, hash table, and HyperLogLog with an error correction table.</li>
</ul>
<p>For a small number of distinct elements, an array is used. When the set size is larger, a hash table is used. For a larger number of elements, HyperLogLog is used, which will occupy a fixed amount of memory.For a small number of distinct elements, an array is used. When the set size is larger, a hash table is used. For a larger number of elements, HyperLogLog is used, which will occupy a fixed amount of memory.</p>
<ul>
<li>Provides the result deterministically (it does not depend on the query processing order).</li>
</ul>
<p>Note</p>
<p>Since it uses 32-bit hash for non- <code>String</code> type, the result will have very high error for cardinalities significantly larger than <code>UINT_MAX</code> (error will raise quickly after a few tens of billions of distinct values), hence in this case you should use uniqCombined64</p>
<p>Compared to the uniq function, the <code>uniqCombined</code> :</p>
<ul>
<li>Consumes several times less memory. </li>
<li>Calculates with several times higher accuracy. </li>
<li>Usually has slightly lower performance. In some scenarios, <code>uniqCombined</code> can perform better than <code>uniq</code> , for example, with distributed queries that transmit a large number of aggregation states over the network.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT uniqCombined(number) FROM numbers(1000);
</code></pre>
<h2 id="uniqExact"><a href="#uniqExact" class="headerlink" title="uniqExact"></a>uniqExact</h2><p>Calculates the exact number of different argument values.</p>
<p>Use the <code>uniqExact</code> function if you absolutely need an exact result. Otherwise use the uniq function.</p>
<p>The <code>uniqExact</code> function uses more memory than <code>uniq</code> , because the size of the state has unbounded growth as the number of different values increases.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">uniqExact(x[, ...])
</code></pre>
<p><strong>Arguments</strong><br>The function takes a variable number of parameters. Parameters can be <code>Tuple</code> , <code>Array</code> , <code>Date</code> , <code>DateTime</code> , <code>String</code> , or numeric types.</p>
<p><strong>Returned value</strong></p>
<ul>
<li>A number UInt64 -type number.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT uniqExact(number) FROM numbers(1000);
</code></pre>
<pre><code class="plain%20text">┌─uniqExact(number)─┐
│ 1000              │
└───────────────────┘
</code></pre>
<h2 id="uniqHLL12"><a href="#uniqHLL12" class="headerlink" title="uniqHLL12"></a>uniqHLL12</h2><p>Calculates the approximate number of different argument values, using the <a href="https://en.wikipedia.org/wiki/HyperLogLog">HyperLogLog</a> algorithm.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">uniqHLL12(x[, ...])
</code></pre>
<p><strong>Arguments</strong><br>The function takes a variable number of parameters. Parameters can be <code>Tuple</code> , <code>Array</code> , <code>Date</code> , <code>DateTime</code> , <code>String</code> , or numeric types.</p>
<p><strong>Returned value</strong></p>
<ul>
<li>A UInt64 -type number.</li>
</ul>
<p><strong>Implementation details</strong><br>Function:</p>
<ul>
<li>Calculates a hash for all parameters in the aggregate, then uses it in calculations. </li>
<li>Uses the HyperLogLog algorithm to approximate the number of different argument values.<br>2^12 5-bit cells are used. The size of the state is slightly more than 2.5 KB. The result is not very accurate (up to ~10% error) for small data sets (&lt;10K elements). However, the result is fairly accurate for high-cardinality data sets (10K-100M), with a maximum error of ~1.6%. Starting from 100M, the estimation error increases, and the function will return very inaccurate results for data sets with extremely high cardinality (1B+ elements).</li>
<li>Provides the determinate result (it does not depend on the query processing order).</li>
</ul>
<p>We do not recommend using this function. In most cases, use the uniq or uniqCombined function.</p>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT uniqHLL12(number) FROM numbers(1000);
</code></pre>
<h2 id="uniqUpTo"><a href="#uniqUpTo" class="headerlink" title="uniqUpTo"></a>uniqUpTo</h2><p>Calculates the number of different argument values if it is less than or equal to N. If the number of different argument values is greater than N, it returns N + 1.</p>
<p>Recommended for use with small Ns, up to 10. The maximum value of N is 100.</p>
<p>For the state of an aggregate function, it uses the amount of memory equal to 1 + N * the size of one value of bytes.</p>
<p>For strings, it stores a non-cryptographic hash of 8 bytes. That is, the calculation is approximated for strings.</p>
<p>The function also works for several arguments.</p>
<p>It works as fast as possible, except for cases when a large N value is used and the number of unique values is slightly less than N.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">uniqUpTo(N)(x)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>N</code> The function takes a variable number of parameters. Parameters can be <code>Tuple</code> , <code>Array</code> , <code>Date</code> , <code>DateTime</code> , <code>String</code> , or numeric types.</li>
</ul>
<p><strong>Returned value</strong></p>
<ul>
<li>A UInt64 -type number.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT uniqUpTo(5)(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─uniqUpTo(5)(number)─┐
│ 6                   │
└─────────────────────┘
</code></pre>
<pre><code class="sql">SELECT uniqUpTo(5)(number) FROM numbers(4);
</code></pre>
<pre><code class="plain%20text">┌─uniqUpTo(5)(number)─┐
│ 4                   │
└─────────────────────┘
</code></pre>
<h2 id="varPop"><a href="#varPop" class="headerlink" title="varPop"></a>varPop</h2><p>Calculates the amount <code>Σ((x - x̅)^2) / n</code> , where <code>n</code> is the sample size and <code>x̅</code> is the average value of <code>x</code> .</p>
<p>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>varPopStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">varPop(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>values</code> — input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>varPop of values. Returns Float64.</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT varPop(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─varPop(number)─┐
│ 8.25e+00       │
└────────────────┘
</code></pre>
<h2 id="varSamp"><a href="#varSamp" class="headerlink" title="varSamp"></a>varSamp</h2><p>Calculates the amount <code>Σ((x - x̅)^2) / (n - 1)</code> , where <code>n</code> is the sample size and <code>x̅</code> is the average value of <code>x</code> .</p>
<p>It represents an unbiased estimate of the variance of a random variable if passed values form its sample.</p>
<p>This function uses a numerically unstable algorithm. If you need <a href="https://en.wikipedia.org/wiki/Numerical_stability">numerical stability</a> in calculations, use the <code>varSampStable</code> function. It works slower but provides a lower computational error.</p>
<p><strong>Syntax</strong></p>
<pre><code class="sql">varSamp(values)
</code></pre>
<p><strong>Arguments</strong></p>
<ul>
<li><code>values</code> — input values.</li>
</ul>
<p><strong>Returned values</strong></p>
<ul>
<li>varSamp of values. Returns Float64.</li>
<li>When <code>n &lt;= 1</code> , returns <code>NaN</code> .</li>
</ul>
<p><strong>Example</strong></p>
<pre><code class="sql">SELECT varSamp(number) FROM numbers(10);
</code></pre>
<pre><code class="plain%20text">┌─varSamp(number)───────┐
│ 9.166666666666666e+00 │
└───────────────────────┘
</code></pre>
<pre><code class="sql">SELECT varSamp(number) FROM numbers(1);
</code></pre>
<pre><code class="plain%20text">┌─varSamp(number)─┐
│ NaN             │
└─────────────────┘
</code></pre>
<h2 id="VAR-POP"><a href="#VAR-POP" class="headerlink" title="VAR_POP"></a>VAR_POP</h2><p>Alias to varPop.</p>
<h2 id="VAR-SAMP"><a href="#VAR-SAMP" class="headerlink" title="VAR_SAMP"></a>VAR_SAMP</h2><p>Alias to varSamp.</p>
